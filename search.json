[{"title":"前端变量的使用和原理","url":"/blog/2023/12/15/%E6%90%9E%E6%87%82%E5%89%8D%E7%AB%AF%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/","content":"不同的环境使用不同的服务器\n开发环境请求的是公司局域网的服务器\n生产环境请求的是真正的服务器，比如云服务\n使用使用 .env.环境名字 定义，运行命令的时候指定环境\nVite + vue3 项目存值：VITE_变量名 &#x3D; xxx\n//.envVITE_GLOBAL = global; //都可以使用//.env.developmentVITE_BASE_URL = 192; //开发环境//.env.productionVITE_BASE_URL = 112; //生产环境-build后的文件内容\n\n取值：import.meta.env.VITE_变量名\nconsole.log(import.meta.env.VITE_BASE_URL)  //生产为112、开发时为192console.log(import.meta.env.VITE_GLOBAL) //都会存在为global\n\nvue-cli 项目 (Webpack + vue2 )0存值：VUEAPP变量名 &#x3D; xxx\n//.envVUE_APP_GLOBAL = global  //都可以使用//.env.developmentVUE_APP_BASE_URL = 192   //开发环境//.env.productionVUE_APP_BASE_URL = 112  //生产环境-build后的文件内容\n\n取值：process.env.VUEAPP变量名\nconsole.log(process.env.VUE_APP_BASE_URL); //生产为112、开发时为192console.log(import.meta.env.VUE_APP_GLOBAL); //都会存在为global\n\n指定环境vite//package.json&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite&quot;, //读取.env.development    &quot;build&quot;: &quot;vite build&quot;, //读取.env.production    &quot;test&quot;: &quot;vite --mode=test&quot; //读取.env.test  &#125;&#125;\n\nwebpack//package.json&#123;  &quot;scripts&quot;: &#123;    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, //读取.env.development    &quot;build&quot;: &quot;vue-cli-service build&quot;, //读取.env.production    &quot;test&quot;: &quot;vue-cli-service serve --mode=test&quot; //读取.env.test  &#125;&#125;\n\n本质node//package.json&#123;  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;cross-env NODE_ENV=development node test.js&quot; //cross-env解决不同系统的兼容性  &#125;&#125;\n\n新建.env 文件\n//.envBASE_URL = 127.0.0.1\n\n//main.jsrequire(&quot;dotenv&quot;).config(); //dotenv库用于从.env文件中读取配置console.log(process.env.NODE_ENV); //developmentconsole.log(process.env.BASE_URL); //127.0.0.1\n\n纯粹的 webpack 打包通过 definePlugins 定义到全局环境\nproject/|-- dist/|-- node_modules/|-- .env|-- app.js|-- package.json|-- webpack.config.js\n\n//package.json&#123;    ...    &quot;scripts&quot;: &#123;        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;    &#125;&#125;//webpack.config.jsmodule.exports = &#123;    mode: process.env.NODE_ENV, //打包方式，是否压缩文件    entry: &quot;./app.js&quot;,    output: &#123;        filename: &#x27;./bundle.js&#x27;    &#125;&#125;\n\n//app.jsconsole.log(process.env);\n\n在这里直接执行npm run build,编译后的文件为：\n//bundle.jsconsole.log(process.env); //这个代码拿到浏览器中是无法运行的,因为process是node的全局变量\n\n那么如何让 process.env 直接编译为变量的呢？\n1.引入 definePlugin\n//webpack.configlet webpack = require(&#x27;webpack&#x27;);require(&#x27;dotenv&#x27;).config();let obj = &#123;&#125;;Object.keys(process.env).forEach((key) =&gt;&#123;    if (key.indexOf(&#x27;VUE_APP&#x27;) !== -1) &#123;        const ipReg = /\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;/;  //如果直接传入127.0.0.1格式的文本会报错        if (ipReg.test(process.env[key])) &#123;            process.env[key] = `&quot;$&#123;process.env[key]&#125;&quot;`        &#125;        obj[key] = process.env[key]    &#125;&#125;)module.exports = &#123;    .... ,    plugins: [        new webpack.DefinePlugin(&#123;            &quot;process.env&quot; : obj,        &#125;)    ]&#125;\n\n执行npm run build生成 bundle.js 文件\n//.envVUE_APP_BASE_URL = &quot;127.0.0.1&quot;;//dist/bundle.jsconsole.log(&#123; VUE_APP_BASE_URL: &quot;127.0.0.1&quot; &#125;), console.log(1111);\n\n这样，我们就成功将环境变量传入 process.env 了\n"},{"title":"koa基础方案","url":"/blog/2023/01/30/koa2/koa%E5%9F%BA%E7%A1%80%E6%96%B9%E6%A1%88/","content":"一. 项目的初始化1 npm 初始化npm init -y\n\n生成package.json文件:\n\n记录项目的依赖\n\n2 git 初始化git init\n\n生成’.git’隐藏文件夹, git 的本地仓库\n3 创建 ReadMe 文件二. 搭建项目1 安装 Koa 框架npm install koa\n\n2 编写最基本的 app创建src/main.js\nconst Koa = require(&quot;koa&quot;);const app = new Koa();app.use((ctx, next) =&gt; &#123;  ctx.body = &quot;hello world&quot;;&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;server is running on http://localhost:3000&quot;);&#125;);\n\n3 测试在终端, 使用node src/main.js\n\n三. 项目的基本优化1 自动重启服务安装 nodemon 工具\nnpm i nodemon -D\n\n编写package.json脚本\n&quot;scripts&quot;: &#123;  &quot;dev&quot;: &quot;nodemon ./src/main.js&quot;,  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125;,\n\n执行npm run dev启动服务\n\n2 读取配置文件安装dotenv, 读取根目录中的.env文件, 将配置写到process.env中\nnpm i dotenv\n\n创建.env文件\nAPP_PORT=8000\n\n创建src/config/config.default.js\nconst dotenv = require(&quot;dotenv&quot;);dotenv.config();// console.log(process.env.APP_PORT)module.exports = process.env;\n\n改写main.js\nconst Koa = require(&quot;koa&quot;);const &#123; APP_PORT &#125; = require(&quot;./config/config.default&quot;);const app = new Koa();app.use((ctx, next) =&gt; &#123;  ctx.body = &quot;hello api&quot;;&#125;);app.listen(APP_PORT, () =&gt; &#123;  console.log(`server is running on http://localhost:$&#123;APP_PORT&#125;`);&#125;);\n\n四. 添加路由路由: 根据不同的 URL, 调用对应处理函数\n1 安装 koa-routernpm i koa-router\n\n步骤:\n\n导入包\n实例化对象\n编写路由\n注册中间件\n\n2 编写路由创建src/router目录, 编写user.route.js\nconst Router = require(&quot;koa-router&quot;);const router = new Router(&#123; prefix: &quot;/users&quot; &#125;);// GET /users/router.get(&quot;/&quot;, (ctx, next) =&gt; &#123;  ctx.body = &quot;hello users&quot;;&#125;);module.exports = router;\n\n3 改写 main.jsconst Koa = require(&quot;koa&quot;);const &#123; APP_PORT &#125; = require(&quot;./config/config.default&quot;);const userRouter = require(&quot;./router/user.route&quot;);const app = new Koa();app.use(userRouter.routes());app.listen(APP_PORT, () =&gt; &#123;  console.log(`server is running on http://localhost:$&#123;APP_PORT&#125;`);&#125;);\n\n五. 目录结构优化1 将 http 服务和 app 业务拆分创建src/app/index.js\nconst Koa = require(&quot;koa&quot;);const userRouter = require(&quot;../router/user.route&quot;);const app = new Koa();app.use(userRouter.routes());module.exports = app;\n\n改写main.js\nconst &#123; APP_PORT &#125; = require(&quot;./config/config.default&quot;);const app = require(&quot;./app&quot;);app.listen(APP_PORT, () =&gt; &#123;  console.log(`server is running on http://localhost:$&#123;APP_PORT&#125;`);&#125;);\n\n2 将路由和控制器拆分路由: 解析 URL, 分布给控制器对应的方法\n控制器: 处理不同的业务\n改写user.route.js\nconst Router = require(&quot;koa-router&quot;);const &#123; register, login &#125; = require(&quot;../controller/user.controller&quot;);const router = new Router(&#123; prefix: &quot;/users&quot; &#125;);// 注册接口router.post(&quot;/register&quot;, register);// 登录接口router.post(&quot;/login&quot;, login);module.exports = router;\n\n创建controller/user.controller.js\nclass UserController &#123;  async register(ctx, next) &#123;    ctx.body = &quot;用户注册成功&quot;;  &#125;  async login(ctx, next) &#123;    ctx.body = &quot;登录成功&quot;;  &#125;&#125;module.exports = new UserController();\n\n六. 解析 body1 安装 koa-bodynpm i koa-body\n\n2 注册中间件改写app/index.js\n\n3 解析请求数据改写user.controller.js文件\nconst &#123; createUser &#125; = require(&quot;../service/user.service&quot;);class UserController &#123;  async register(ctx, next) &#123;    // 1. 获取数据    // console.log(ctx.request.body)    const &#123; user_name, password &#125; = ctx.request.body;    // 2. 操作数据库    const res = await createUser(user_name, password);    // console.log(res)    // 3. 返回结果    ctx.body = ctx.request.body;  &#125;  async login(ctx, next) &#123;    ctx.body = &quot;登录成功&quot;;  &#125;&#125;module.exports = new UserController();\n\n4 拆分 service 层service 层主要是做数据库处理\n创建src/service/user.service.js\nclass UserService &#123;  async createUser(user_name, password) &#123;    // todo: 写入数据库    return &quot;写入数据库成功&quot;;  &#125;&#125;module.exports = new UserService();\n\n七. 集成 sequlizesequelize ORM 数据库工具\nORM: 对象关系映射(Object Relational Mapping）\n\n数据表映射(对应)一个类\n数据表中的数据行(记录)对应一个对象\n数据表字段对应对象的属性\n数据表的操作对应对象的方法\n\n1 安装 sequelizenpm i mysql2 sequelize\n\n2 连接数据库src/db/seq.js\nconst &#123; Sequelize &#125; = require(&quot;sequelize&quot;);const &#123;  MYSQL_HOST,  MYSQL_PORT,  MYSQL_USER,  MYSQL_PWD,  MYSQL_DB,&#125; = require(&quot;../config/config.default&quot;);const seq = new Sequelize(MYSQL_DB, MYSQL_USER, MYSQL_PWD, &#123;  host: MYSQL_HOST,  dialect: &quot;mysql&quot;,&#125;);seq  .authenticate()  .then(() =&gt; &#123;    console.log(&quot;数据库连接成功&quot;);  &#125;)  .catch((err) =&gt; &#123;    console.log(&quot;数据库连接失败&quot;, err);  &#125;);module.exports = seq;\n\n3 编写配置文件APP_PORT = 8000MYSQL_HOST = localhostMYSQL_PORT = 3306MYSQL_USER = rootMYSQL_PWD = 123456MYSQL_DB = zdsc\n\n八. 创建 User 模型1 拆分 Model 层sequelize 主要通过 Model 对应数据表\n创建src/model/user.model.js\nconst &#123; DataTypes &#125; = require(&quot;sequelize&quot;);const seq = require(&quot;../db/seq&quot;);// 创建模型(Model zd_user -&gt; 表 zd_users)const User = seq.define(&quot;zd_user&quot;, &#123;  // id 会被sequelize自动创建, 管理  user_name: &#123;    type: DataTypes.STRING,    allowNull: false,    unique: true,    comment: &quot;用户名, 唯一&quot;,  &#125;,  password: &#123;    type: DataTypes.CHAR(64),    allowNull: false,    comment: &quot;密码&quot;,  &#125;,  is_admin: &#123;    type: DataTypes.BOOLEAN,    allowNull: false,    defaultValue: 0,    comment: &quot;是否为管理员, 0: 不是管理员(默认); 1: 是管理员&quot;,  &#125;,&#125;);// 强制同步数据库(创建数据表)// User.sync(&#123; force: true &#125;)module.exports = User;\n\n九. 添加用户入库所有数据库的操作都在 Service 层完成, Service 调用 Model 完成数据库操作\n改写src/service/user.service.js\nconst User = require(&quot;../model/use.model&quot;);class UserService &#123;  async createUser(user_name, password) &#123;    // 插入数据    // User.create(&#123;    //   // 表的字段    //   user_name: user_name,    //   password: password    // &#125;)    // await表达式: promise对象的值    const res = await User.create(&#123; user_name, password &#125;);    // console.log(res)    return res.dataValues;  &#125;&#125;module.exports = new UserService();\n\n同时, 改写user.controller.js\nconst &#123; createUser &#125; = require(&quot;../service/user.service&quot;);class UserController &#123;  async register(ctx, next) &#123;    // 1. 获取数据    // console.log(ctx.request.body)    const &#123; user_name, password &#125; = ctx.request.body;    // 2. 操作数据库    const res = await createUser(user_name, password);    // console.log(res)    // 3. 返回结果    ctx.body = &#123;      code: 0,      message: &quot;用户注册成功&quot;,      result: &#123;        id: res.id,        user_name: res.user_name,      &#125;,    &#125;;  &#125;  async login(ctx, next) &#123;    ctx.body = &quot;登录成功&quot;;  &#125;&#125;module.exports = new UserController();\n\n十. 错误处理在控制器中, 对不同的错误进行处理, 返回不同的提示错误提示, 提高代码质量\nconst &#123; createUser, getUerInfo &#125; = require(&quot;../service/user.service&quot;);class UserController &#123;  async register(ctx, next) &#123;    // 1. 获取数据    // console.log(ctx.request.body)    const &#123; user_name, password &#125; = ctx.request.body;    // 合法性    if (!user_name || !password) &#123;      console.error(&quot;用户名或密码为空&quot;, ctx.request.body);      ctx.status = 400;      ctx.body = &#123;        code: &quot;10001&quot;,        message: &quot;用户名或密码为空&quot;,        result: &quot;&quot;,      &#125;;      return;    &#125;    // 合理性    if (getUerInfo(&#123; user_name &#125;)) &#123;      ctx.status = 409;      ctx.body = &#123;        code: &quot;10002&quot;,        message: &quot;用户已经存在&quot;,        result: &quot;&quot;,      &#125;;      return;    &#125;    // 2. 操作数据库    const res = await createUser(user_name, password);    // console.log(res)    // 3. 返回结果    ctx.body = &#123;      code: 0,      message: &quot;用户注册成功&quot;,      result: &#123;        id: res.id,        user_name: res.user_name,      &#125;,    &#125;;  &#125;  async login(ctx, next) &#123;    ctx.body = &quot;登录成功&quot;;  &#125;&#125;module.exports = new UserController();\n\n在 service 中封装函数\nconst User = require(&quot;../model/use.model&quot;);class UserService &#123;  async createUser(user_name, password) &#123;    // 插入数据    // await表达式: promise对象的值    const res = await User.create(&#123; user_name, password &#125;);    // console.log(res)    return res.dataValues;  &#125;  async getUerInfo(&#123; id, user_name, password, is_admin &#125;) &#123;    const whereOpt = &#123;&#125;;    id &amp;&amp; Object.assign(whereOpt, &#123; id &#125;);    user_name &amp;&amp; Object.assign(whereOpt, &#123; user_name &#125;);    password &amp;&amp; Object.assign(whereOpt, &#123; password &#125;);    is_admin &amp;&amp; Object.assign(whereOpt, &#123; is_admin &#125;);    const res = await User.findOne(&#123;      attributes: [&quot;id&quot;, &quot;user_name&quot;, &quot;password&quot;, &quot;is_admin&quot;],      where: whereOpt,    &#125;);    return res ? res.dataValues : null;  &#125;&#125;module.exports = new UserService();\n\n十一. 拆分中间件为了使代码的逻辑更加清晰, 我们可以拆分一个中间件层, 封装多个中间件函数\n\n1 拆分中间件添加src/middleware/user.middleware.js\nconst &#123; getUerInfo &#125; = require(&quot;../service/user.service&quot;);const &#123; userFormateError, userAlreadyExited &#125; = require(&quot;../constant/err.type&quot;);const userValidator = async (ctx, next) =&gt; &#123;  const &#123; user_name, password &#125; = ctx.request.body;  // 合法性  if (!user_name || !password) &#123;    console.error(&quot;用户名或密码为空&quot;, ctx.request.body);    ctx.app.emit(&quot;error&quot;, userFormateError, ctx);    return;  &#125;  await next();&#125;;const verifyUser = async (ctx, next) =&gt; &#123;  const &#123; user_name &#125; = ctx.request.body;  if (getUerInfo(&#123; user_name &#125;)) &#123;    ctx.app.emit(&quot;error&quot;, userAlreadyExited, ctx);    return;  &#125;  await next();&#125;;module.exports = &#123;  userValidator,  verifyUser,&#125;;\n\n2 统一错误处理\n在出错的地方使用ctx.app.emit提交错误\n在 app 中通过app.on监听\n\n编写统一的错误定义文件\nmodule.exports = &#123;  userFormateError: &#123;    code: &quot;10001&quot;,    message: &quot;用户名或密码为空&quot;,    result: &quot;&quot;,  &#125;,  userAlreadyExited: &#123;    code: &quot;10002&quot;,    message: &quot;用户已经存在&quot;,    result: &quot;&quot;,  &#125;,&#125;;\n\n3 错误处理函数module.exports = (err, ctx) =&gt; &#123;  let status = 500;  switch (err.code) &#123;    case &quot;10001&quot;:      status = 400;      break;    case &quot;10002&quot;:      status = 409;      break;    default:      status = 500;  &#125;  ctx.status = status;  ctx.body = err;&#125;;\n\n改写app/index.js\nconst errHandler = require(&quot;./errHandler&quot;);// 统一的错误处理app.on(&quot;error&quot;, errHandler);\n\n十二. 加密在将密码保存到数据库之前, 要对密码进行加密处理\n123123abc (加盐) 加盐加密\n1 安装 bcryptjsnpm i bcryptjs\n\n2 编写加密中间件const crpytPassword = async (ctx, next) =&gt; &#123;  const &#123; password &#125; = ctx.request.body;  const salt = bcrypt.genSaltSync(10);  // hash保存的是 密文  const hash = bcrypt.hashSync(password, salt);  ctx.request.body.password = hash;  await next();&#125;;\n\n3 在 router 中使用改写user.router.js\nconst Router = require(&quot;koa-router&quot;);const &#123;  userValidator,  verifyUser,  crpytPassword,&#125; = require(&quot;../middleware/user.middleware&quot;);const &#123; register, login &#125; = require(&quot;../controller/user.controller&quot;);const router = new Router(&#123; prefix: &quot;/users&quot; &#125;);// 注册接口router.post(&quot;/register&quot;, userValidator, verifyUser, crpytPassword, register);// 登录接口router.post(&quot;/login&quot;, login);module.exports = router;\n\n十三. 登录验证流程:\n\n验证格式\n验证用户是否存在\n验证密码是否匹配\n\n改写src/middleware/user.middleware.js\nconst bcrypt = require(&quot;bcryptjs&quot;);const &#123; getUerInfo &#125; = require(&quot;../service/user.service&quot;);const &#123;  userFormateError,  userAlreadyExited,  userRegisterError,  userDoesNotExist,  userLoginError,  invalidPassword,&#125; = require(&quot;../constant/err.type&quot;);const userValidator = async (ctx, next) =&gt; &#123;  const &#123; user_name, password &#125; = ctx.request.body;  // 合法性  if (!user_name || !password) &#123;    console.error(&quot;用户名或密码为空&quot;, ctx.request.body);    ctx.app.emit(&quot;error&quot;, userFormateError, ctx);    return;  &#125;  await next();&#125;;const verifyUser = async (ctx, next) =&gt; &#123;  const &#123; user_name &#125; = ctx.request.body;  // if (await getUerInfo(&#123; user_name &#125;)) &#123;  //   ctx.app.emit(&#x27;error&#x27;, userAlreadyExited, ctx)  //   return  // &#125;  try &#123;    const res = await getUerInfo(&#123; user_name &#125;);    if (res) &#123;      console.error(&quot;用户名已经存在&quot;, &#123; user_name &#125;);      ctx.app.emit(&quot;error&quot;, userAlreadyExited, ctx);      return;    &#125;  &#125; catch (err) &#123;    console.error(&quot;获取用户信息错误&quot;, err);    ctx.app.emit(&quot;error&quot;, userRegisterError, ctx);    return;  &#125;  await next();&#125;;const crpytPassword = async (ctx, next) =&gt; &#123;  const &#123; password &#125; = ctx.request.body;  const salt = bcrypt.genSaltSync(10);  // hash保存的是 密文  const hash = bcrypt.hashSync(password, salt);  ctx.request.body.password = hash;  await next();&#125;;const verifyLogin = async (ctx, next) =&gt; &#123;  // 1. 判断用户是否存在(不存在:报错)  const &#123; user_name, password &#125; = ctx.request.body;  try &#123;    const res = await getUerInfo(&#123; user_name &#125;);    if (!res) &#123;      console.error(&quot;用户名不存在&quot;, &#123; user_name &#125;);      ctx.app.emit(&quot;error&quot;, userDoesNotExist, ctx);      return;    &#125;    // 2. 密码是否匹配(不匹配: 报错)    if (!bcrypt.compareSync(password, res.password)) &#123;      ctx.app.emit(&quot;error&quot;, invalidPassword, ctx);      return;    &#125;  &#125; catch (err) &#123;    console.error(err);    return ctx.app.emit(&quot;error&quot;, userLoginError, ctx);  &#125;  await next();&#125;;module.exports = &#123;  userValidator,  verifyUser,  crpytPassword,  verifyLogin,&#125;;\n\n定义错误类型\nmodule.exports = &#123;  userFormateError: &#123;    code: &quot;10001&quot;,    message: &quot;用户名或密码为空&quot;,    result: &quot;&quot;,  &#125;,  userAlreadyExited: &#123;    code: &quot;10002&quot;,    message: &quot;用户已经存在&quot;,    result: &quot;&quot;,  &#125;,  userRegisterError: &#123;    code: &quot;10003&quot;,    message: &quot;用户注册错误&quot;,    result: &quot;&quot;,  &#125;,  userDoesNotExist: &#123;    code: &quot;10004&quot;,    message: &quot;用户不存在&quot;,    result: &quot;&quot;,  &#125;,  userLoginError: &#123;    code: &quot;10005&quot;,    message: &quot;用户登录失败&quot;,    result: &quot;&quot;,  &#125;,  invalidPassword: &#123;    code: &quot;10006&quot;,    message: &quot;密码不匹配&quot;,    result: &quot;&quot;,  &#125;,&#125;;\n\n改写路由\n// 登录接口router.post(&quot;/login&quot;, userValidator, verifyLogin, login);\n\n十四. 用户的认证登录成功后, 给用户颁发一个令牌 token, 用户在以后的每一次请求中携带这个令牌.\njwt: jsonwebtoken\n\nheader: 头部\npayload: 载荷\nsignature: 签名\n\n1 颁发 token1) 安装 jsonwebtokennpm i jsonwebtoken\n\n2) 在控制器中改写 login 方法async login(ctx, next) &#123;  const &#123; user_name &#125; = ctx.request.body  // 1. 获取用户信息(在token的payload中, 记录id, user_name, is_admin)  try &#123;    // 从返回结果对象中剔除password属性, 将剩下的属性放到res对象    const &#123; password, ...res &#125; = await getUerInfo(&#123; user_name &#125;)    ctx.body = &#123;      code: 0,      message: &#x27;用户登录成功&#x27;,      result: &#123;        token: jwt.sign(res, JWT_SECRET, &#123; expiresIn: &#x27;1d&#x27; &#125;),      &#125;,    &#125;  &#125; catch (err) &#123;    console.error(&#x27;用户登录失败&#x27;, err)  &#125;&#125;\n\n3) 定义私钥在.env定义\nJWT_SECRET = xzd\n\n2 用户认证1) 创建 auth 中间件const jwt = require(&quot;jsonwebtoken&quot;);const &#123; JWT_SECRET &#125; = require(&quot;../config/config.default&quot;);const &#123; tokenExpiredError, invalidToken &#125; = require(&quot;../constant/err.type&quot;);const auth = async (ctx, next) =&gt; &#123;  const &#123; authorization &#125; = ctx.request.header;  const token = authorization.replace(&quot;Bearer &quot;, &quot;&quot;);  console.log(token);  try &#123;    // user中包含了payload的信息(id, user_name, is_admin)    const user = jwt.verify(token, JWT_SECRET);    ctx.state.user = user;  &#125; catch (err) &#123;    switch (err.name) &#123;      case &quot;TokenExpiredError&quot;:        console.error(&quot;token已过期&quot;, err);        return ctx.app.emit(&quot;error&quot;, tokenExpiredError, ctx);      case &quot;JsonWebTokenError&quot;:        console.error(&quot;无效的token&quot;, err);        return ctx.app.emit(&quot;error&quot;, invalidToken, ctx);    &#125;  &#125;  await next();&#125;;module.exports = &#123;  auth,&#125;;\n\n2) 改写 router// 修改密码接口router.patch(&quot;/&quot;, auth, (ctx, next) =&gt; &#123;  console.log(ctx.state.user);  ctx.body = &quot;修改密码成功&quot;;&#125;);\n\n新的内容\n","tags":["koa2"]},{"title":"ts的意义与麻烦","url":"/blog/2023/12/30/typescript/ts%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E9%BA%BB%E7%83%A6/","content":"意义最大的意义就是避免写错变量名，方法名，屏蔽掉低级错误\n\n编写一些公用方法和全局配置对象，用于提醒使用者传参的key值和value类型等\n//apis/users.tsexport interface ListParamsType &#123;    pageNum: number,    pageSize: 10 | 30 | 50  //字面量&#125;export const getList = (params:ListParamsType)=&gt; &#123;    ...这里请求数据&#125;\n\n\n\n声明组件props\n减少传参错误，以及一些不必要的TS报错\ninterface Props &#123;  item: RouteRecordRaw,  basePath?:string&#125;const props = withDefaults(defineProps&lt;Props&gt;(), &#123;    basePath:&#x27;&#x27;&#125;)\n\n一些使用TS编写的第三方库，在使用的时候可以检查有没有调错方法等\n这里以Vue-Router为例：\n//router/index.tsconst router = createRouter(&#123;    history: createWebHistory(),    routes: [        &#123;             path: &#x27;/login&#x27;,             //如果你没有传必需的component属性则会报错            //Type &#x27;&#123; path: string; &#125;&#x27; is not assignable to type &#x27;RouteRecordRaw&#x27;.        &#125;,    ]&#125;)\n\n如果不知道createRouter要传入什么参数可以通过移入鼠标查看\n\n\n\n麻烦\n阶段类型不匹配\n调用初始化为空对象的但是后来会被赋值的属性：\n//SidebarItem.vue&lt;template&gt;    &lt;div v-if=&quot;!item.hidden&quot;&gt;        &lt;template v-if=&quot;hasOneShowingChild(item.children,item)&quot;&gt;             &lt;!-- Property &#x27;path&#x27; does not exist on type &#x27;&#123;&#125;&#x27; --&gt;            &lt;el-menu-item :index=&quot;onlyChild.path&quot;&gt;                 &lt;!-- Property &#x27;title&#x27; does not exist on type &#x27;&#123;&#125;&#x27; --&gt;                &#123;&#123; onlyChild.meta.title &#125;&#125;             &lt;/el-menu-item&gt;        &lt;/template&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;;let onlyChild = reactive(&#123;&#125;);  //就算在代码执行过程中赋值，但是调用处仍然报错&lt;/script&gt;\n\n我们对页面上会调用的变量进行类型定义并断言\n&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;;interface OnlyChildType &#123;    meta:&#123;        title:string    &#125;,    path:string&#125;let onlyChild = reactive(&#123;&#125; as OnlyChildType);&lt;/script&gt;\n\n这个时候去调用meta, path等属性就不会有错误提示了\n\nTS编写的第三方库时，需要定义某个参数为库的某个类型\n我们定义了一个动态添加路由的方法，会出现如下报错\n//Parameter &#x27;routes&#x27; implicitly has an &#x27;any&#x27; typefunction addRoute(routes) &#123;     routes.forEach(route =&gt; &#123;        router.addRoute(route)    &#125;)&#125;\n\n可是要传入第三方库的参数类型我们该怎么定义？\n一般来说，编写较为规范的库都会直接暴露出对应的TS类型可以让我们直接导入\nimport type &#123; RouteRecordRaw &#125; from &#x27;vue-router&#x27;//这个时候使用引入的类型就非常完美了function addRoute(routes:RouteRecordRaw[]) &#123;     routes.forEach(route =&gt; &#123;        router.addRoute(route)    &#125;)&#125;\n\n但是，如果如果不规范的库无法直接导入怎么办？\n​\ta.这里我们还是以Vue-Router为例，通过node_modules找到对应库根目录的package.json\n​\tb.找到其types属性，该属性指向使用import type  导入类型时所查找的位置\n​\tc.然后找到对应的类型查看其如何定义\n\n一些常见的DOM类型报错\n这里以渲染节点文本的内容为例子\n\n\n&lt;div @click=&quot;(e)=&gt;&#123;        let target = e.target         //Property &#x27;innerText&#x27; does not exist on type &#x27;EventTarget&#x27;        target.getContext(&#x27;2D&#x27;)  //因为dom的类型推论错误    &#125;&quot;&gt;&lt;/div&gt;\n\n​\t这时候加上正确的类型断言：\n&lt;div @click=&quot;(e)=&gt;&#123;    let target = e.target as HTMLElement    target.innerTExt = &#x27;test&#x27;&#125;&quot;&gt;\n\n​\t完美解决~\n","tags":["TypeScript"]},{"title":"项目架构之搭建登录架构解决方案与实现","url":"/blog/2024/03/02/vue3%E5%90%8E%E5%8F%B0%E7%BB%BC%E5%90%88%E6%96%B9%E6%A1%88/2.%20%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/","content":"\n准备工作：引入 ElementUI plus , 全局应用 normalize.css 等\n\nIcon 图标处理方案：SvgIcon在上一小节中我们完成了登陆页面的基本样式 。但是现在在登录页面中，还存在着最后一个样式问题，那就是 icon 图标。\n在我们的项目中所使用的 icon 图标，一共分为两类：\n\nelement-plus 的图标\n自定义的 svg 图标\n\n这也是通常情况下企业级项目开发时，所遇到的一种常见情况。\n对于 element-plus 的图标我们可以直接通过 el-icon 来进行显示，但是自定义图标的话，我们暂时还缺少显示的方式，所以说我们需要一个自定义的组件，来显示我们自定义的 svg 图标。\n那么这种自定义组件处理 自定义 svg 图标的形式，就是我们在面临这种问题时的通用解决方案。\n那么对于这个组件的话，它就需要拥有两种能力：\n\n显示外部 svg 图标\n显示项目内的 svg 图标\n\n基于以上概念，我们可以创建出以下对应代码：\n创建 components/SvgIcon/index.vue：\n&lt;template&gt;  &lt;!-- 展示外部图标 --&gt;  &lt;div    v-if=&quot;isExternal&quot;    class=&quot;external-icon svg-icon&quot;    :style=&quot;styleExternalIcon&quot;    :class=&quot;className&quot;  &gt;&lt;/div&gt;  &lt;!-- 展示内部图标 --&gt;  &lt;svg v-else :class=&quot;className&quot; aria-hidden=&quot;true&quot; class=&quot;svg-icon&quot;&gt;    &lt;use :xlink:href=&quot;symbolId&quot; :fill=&quot;color&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; computed &#125; from &quot;vue&quot;;import &#123; isExternal as external &#125; from &quot;@/util/validate&quot;;interface Props &#123;  name: string;  color?: string;  className?: string;&#125;const props = withDefaults(defineProps&lt;Props&gt;(), &#123;  color: &quot;#000&quot;,  className: &quot;&quot;,&#125;);const isExternal = computed(() =&gt; &#123;  return external(props.name);&#125;);const styleExternalIcon = computed(() =&gt; (&#123;  mask: `url($&#123;props.name&#125;) no-repeat 50% 50%`,  &quot;-webkit-mask&quot;: `url($&#123;props.name&#125;) no-repeat 50% 50%`,&#125;));const symbolId = computed(() =&gt; &#123;  return `#icon-$&#123;props.name&#125;`;&#125;);&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.svg-icon &#123;  width: 1em;  height: 1em;&#125;.external-icon &#123;  background-color: currentColor;  mask-size: cover !important;  display: inline-block;&#125;&lt;/style&gt;\n\n创建 utils/validate.js：\n/** * 判断是否为外部资源 */export function isExternal(path) &#123;  return /^(https?:|mailto:|tel:)/.test(path);&#125;\n\n在 views/login/index.vue 中使用 外部 svg\n&lt;span class=&quot;svg-container&quot;&gt;  &lt;svg-icon icon=&quot;https://res.lgdsunday.club/user.svg&quot;&gt;&lt;/svg-icon&gt;&lt;/span&gt;\n\n外部图标可正常展示。\n处理内部 svg 图标显示在上一章中，我们创建了 SvgIcon 组件用于显示 非 Element-ui 的图标。但是目前我们只处理了 外部 svg 的图标展示，内部的图标还无法展示。\n所以这一小节，我们就需要处理 内部的 svg 图标展示。\n\n首先导入所有的 svg 图标到项目中/src/icons/index.js\n\n在 icons 下创建 index.js 文件，该文件中需要完成两件事情：\n\n导入所有的 svg 图标\n完成 SvgIcon 的全局注册\n\n\n得出以下代码：\nimport SvgIcon from &quot;@/components/SvgIcon/index.vue&quot;;const componentsGroup: any = &#123; SvgIcon &#125;;export default &#123;  install(app: any) &#123;    Object.keys(componentsGroup).forEach((key) =&gt; &#123;      app.component(key, componentsGroup[key]);    &#125;);  &#125;,&#125;;\n\n在 main.js 中引入该文件\n...// 导入 svgIconimport icons from &#x27;@/icons/index.ts&#x27;;...app.use(icons);...\n\n打开浏览器，我们发现 图标依然无法展示！ 这又是因为什么原因呢？\n\n\nvite-plugin-svg-icons那么想要使用该插件， 我们需要做两件事情：\n\n下载该插件，执行npm i --save-dev vite-plugin-svg-icons\n\n打开 vite.config.ts 文件，新增如下配置：\n...import &#123; createSvgIconsPlugin &#125; from &#x27;vite-plugin-svg-icons&#x27;;import path from &#x27;path&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    ...,    createSvgIconsPlugin(&#123;      // Specify the icon folder to be cached      iconDirs: [path.resolve(process.cwd(), &#x27;src/icons/svg&#x27;)],      // Specify symbolId format      symbolId: &#x27;icon-[dir]-[name]&#x27;    &#125;)  ],  ...&#125;);\n\n处理完以上配置之后，图标即可显示！\n完善登录表单校验表单校验是表单使用的一个通用能力，在 element-plus 中想要为表单进行表单校验那么我们需要关注以下三点：\n\n为 el-form 绑定 model 属性\n为 el-form 绑定 rules 属性\n为 el-form-item 绑定 prop 属性\n\n保证以上三点即可为 el-from 添加表单校验功能。\n以下为对应的代码实现：\nviews&#x2F;login\n&lt;template&gt;  &lt;div class=&quot;login-container&quot;&gt;    &lt;el-form class=&quot;login-form&quot; :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot; ref=“form&#x27;&gt;      ...      &lt;el-form-item prop=&quot;username&quot;&gt;        ...        &lt;el-input         ...          v-model=&quot;loginForm.username&quot;        /&gt;      &lt;/el-form-item&gt;      &lt;el-form-item prop=&quot;password&quot;&gt;        ...        &lt;el-input          ...          v-model=&quot;loginForm.password&quot;        /&gt;        ...      &lt;/el-form-item&gt;\t\t...    &lt;/el-form&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; validatePassword &#125; from &#x27;./rules&#x27;// 数据源const loginForm = ref(&#123;  username: &#x27;super-admin&#x27;,  password: &#x27;123456&#x27;&#125;)// 验证规则const loginRules = ref(&#123;  username: [    &#123;      required: true,      trigger: &#x27;blur&#x27;,      message: &#x27;用户名为必填项&#x27;    &#125;  ],  password: [    &#123;      required: true,      trigger: &#x27;blur&#x27;,      validator: validatePassword()    &#125;  ]&#125;)&lt;/script&gt;\n\nviews&#x2F;login&#x2F;rules.js\nexport const validatePassword = () =&gt; &#123;  return (rule, value, callback) =&gt; &#123;    if (value.length &lt; 6) &#123;      callback(new Error(&quot;密码不能少于6位&quot;));    &#125; else &#123;      callback();    &#125;  &#125;;&#125;;\n\n通用后台登录方案解析对于登录操作在后台项目中是一个通用的解决方案，具体可以分为以下几点：\n\n封装 axios 模块\n封装 接口请求 模块\n封装登录请求动作\n保存服务端返回的 token\n登录鉴权\n\n这些内容就共同的组成了一套 后台登录解决方案 。\n配置环境变量封装 axios 模块首先我们先去完成第一步：封装 axios 模块。\n在当前这个场景下，我们希望封装出来的 axios 模块，至少需要具备一种能力，那就是：根据当前模式的不同，设定不同的 BaseUrl ，因为通常情况下企业级项目在 开发状态 和 生产状态 下它的 baseUrl 是不同的。\n对于 @vue/cli 来说，它具备三种不同的模式：\n\ndevelopment\ntest\nproduction\n\n根据我们前面所提到的 开发状态和生产状态 那么此时我们的 axios 必须要满足：在 开发 || 生产 状态下，可以设定不同 BaseUrl 的能力\n那么想要解决这个问题，就必须要使用到 vite 所提提供的环境变量去进行实现。\n我们可以在项目中创建两个文件：\n\n.env.development\n.env.production\n\n它们分别对应 开发状态 和 生产状态。\n我们可以在上面两个文件中分别写入以下代码：\n**.env.development**：\n# 标志ENV = &#x27;development&#x27;# base apiVITE_APP_BASE_API = &#x27;/api&#x27;\n\n.env.production：\n# 标志ENV = &#x27;production&#x27;# base apiVITE_APP_BASE_API = &#x27;/prod-api&#x27;\n\n有了这两个文件之后，我们就可以创建对应的 axios 模块\n创建 utils/request.js ，写入如下代码：\nimport axios from &quot;axios&quot;;const service = axios.create(&#123;  baseURL: import.meta.env.VITE_APP_BASE_API,  timeout: 5000,&#125;);export default service;\n\n封装请求动作有了 axios 模块之后，接下来我们就可以\n\n封装接口请求模块\n封装登录请求动作\n\n封装接口请求模块：\n创建 api 文件夹，创建 sys.js：\nimport request from &#x27;@/util/request&#x27;;import type &#123; LoginData &#125; from &#x27;./types/user&#x27;;import type &#123; loginResponse &#125; from &#x27;./types/user&#x27;;/** * 登录export const login = (data: LoginData) =&gt; &#123;  /**   * 如果不限定返回的数据格式，在引用的时候ts会判断返回值为Promise对象   */  return request.post&lt;any, loginResponse&gt;(&#x27;/sys/login&#x27;, data);&#125;;\n\n封装登录请求动作：\n该动作我们期望把它封装到 pinia的 action 中\n在 store 下创建 user.ts 模块，用于处理所有和 用户相关 的内容（此处需要使用第三方包 md5 ）：\nimport &#123; defineStore &#125; from &quot;pinia&quot;;import type &#123; LoginData &#125; from &quot;@/apis/types/user&quot;;import &#123; login &#125; from &quot;@/apis/user&quot;;export const useUserStore = defineStore(&quot;user&quot;, &#123;  state: () =&gt; (&#123;    token: getItem(&quot;token&quot;),  &#125;),  getters: &#123;&#125;,  actions: &#123;    async userLogin(params: LoginData) &#123;      try &#123;        const data = await login(params);        this.token = data.token;        setItem(&quot;token&quot;, data.token);        return Promise.resolve(&quot;ok&quot;);      &#125; catch (error) &#123;        return Promise.reject(error);      &#125;    &#125;,  &#125;,&#125;);\n\n调用：\n//login.vueimport &#123; useUserStore &#125; from &#x27;@/stores/user&#x27;;...const store = useUserStore();const router = useRouter();const handleLogin = async () =&gt; &#123;  try &#123;    loading.value = true;    await store.userLogin(&#123;      username: loginForm.username,      password: md5(loginForm.password)    &#125;);    ElMessage.success(&#x27;登录成功&#x27;);    router.push(&#x27;/&#x27;);  &#125; catch (error) &#123;    console.log(error);  &#125; finally &#123;    loading.value = false;  &#125;&#125;;\n\n登录触发动作在 login 中，触发定义的 action\n&lt;template&gt;  &lt;el-button    type=&quot;primary&quot;    style=&quot;width: 100%; margin-bottom: 30px&quot;    :loading=&quot;loading&quot;    @click=&quot;handleLogin&quot;    &gt;登录&lt;/el-button  &gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; User, Lock &#125; from &#x27;@element-plus/icons-vue&#x27;;import &#123; reactive, ref &#125; from &#x27;vue&#x27;;import &#123; useRouter &#125; from &#x27;vue-router&#x27;;import &#123; pwdValidate &#125; from &#x27;./rule&#x27;;import &#123; useUserStore &#125; from &#x27;@/stores/user&#x27;;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;;import md5 from &#x27;md5&#x27;;......const loading = ref(false);const store = useUserStore();const router = useRouter();const handleLogin = async () =&gt; &#123;  try &#123;    loading.value = true;    await store.userLogin(&#123;      username: loginForm.username,      password: md5(loginForm.password)    &#125;);    ElMessage.success(&#x27;登录成功&#x27;);    router.push(&#x27;/&#x27;);  &#125; catch (error) &#123;    console.log(error);  &#125; finally &#123;    loading.value = false;  &#125;&#125;;&lt;/script&gt;\n\n触发之后会得到当前请求的接口不存在的错误。\n出现这个问题的原因，是因为我们在前面配置环境变量时指定了 开发环境下，请求的 BaseUrl 为 /api ，所以我们真实发出的请求为：/api/sys/login 。\n这样的一个请求会被自动键入到当前前端所在的服务中，所以我们最终就得到了 http://localhost:5173/api/sys/login 这样的一个请求路径, 没有请求到服务所在的地址\n而想要处理这个问题，那么可以通过指定代理的形式，代理当前的 url 请求。\n在 vite.config.js 中，加入以下代码：\nmodule.exports = &#123;  server: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        //获取数据的服务器地址设置        target: &#x27;http://localhost:3004&#x27;,        //需要代理跨域        changeOrigin: true      &#125;    &#125;  &#125;,  ...&#125;\n\n重新启动服务，再次进行请求，即可得到成功响应。\n本地缓存处理方案通常情况下，在获取到 token 之后，我们会把 token 进行缓存，而缓存的方式将会分为两种：\n\n本地缓存：LocalStorage\n全局状态管理：pina\n\n保存在 LocalStorage 是为了方便实现 自动登录功能\n保存在 pinia 中是为了后面在其他位置进行使用\n那么下面我们就分别来实现对应的缓存方案：\nLocalStorage：\n\n创建 utils/storage.js 文件，封装三个对应方法：\n/** * 存储数据 */export const setItem = (key: string, value: unknown) =&gt; &#123;  let stringValue: string;  if (typeof value === &quot;object&quot; &amp;&amp; value !== null) &#123;    stringValue = JSON.stringify(value);  &#125; else &#123;    // 将非对象类型的值转化为字符串，因为localStorage的第二个参数必须为string    stringValue = `$&#123;value&#125;`;  &#125;  //  localStorage.setItem(key, stringValue);&#125;;/** * 获取数据 */export const getItem = (key: string) =&gt; &#123;  const data = localStorage.getItem(key);  try &#123;    return JSON.parse(data);  &#125; catch (err) &#123;    return data;  &#125;&#125;;/** * 删除数据 */export const removeItem = (key: string) =&gt; &#123;  window.localStorage.removeItem(key);&#125;;/** * 删除所有数据 */export const removeAllItem = () =&gt; &#123;  window.localStorage.clear();&#125;;\n\n在 pinia 的 user 模块下，处理 token 的保存\nimport &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; login &#125; from &quot;@/apis/user&quot;;import &#123; setItem, getItem &#125; from &quot;@/util/storage&quot;;import &#123; TOKEN &#125; from &quot;@/constant/index&quot;;import type &#123; LoginData &#125; from &quot;@/apis/types/user&quot;;export const useUserStore = defineStore(&quot;user&quot;, &#123;  state: () =&gt; (&#123;    token: getItem(TOKEN) || &quot;&quot;,  &#125;),  getters: &#123;&#125;,  actions: &#123;    async userLogin(params: LoginData) &#123;      try &#123;        const data = await login(params);        this.token = data.token;        setItem(TOKEN, data.token);        return Promise.resolve(&quot;ok&quot;);      &#125; catch (error) &#123;        return Promise.reject(error);      &#125;    &#125;,  &#125;,&#125;);\n\n处理保存的过程中，需要创建 constant 常量目录 constant/index.js\nexport const TOKEN = &quot;token&quot;;\n\n此时，当点击登陆时，即可把 token 保存至 pinia 与 localStorage 中\n响应数据的统一处理在 utils/request.js 中实现以下代码：\nimport axios from &#x27;axios&#x27;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;...// 响应拦截器service.interceptors.response.use(  response =&gt; &#123;    const &#123; success, message, data &#125; = response.data    //   要根据success的成功与否决定下面的操作    if (success) &#123;      return data    &#125; else &#123;      // 业务错误      ElMessage.error(message) // 提示错误消息      return Promise.reject(new Error(message))    &#125;  &#125;,  error =&gt; &#123;    // TODO: 将来处理 token 超时问题    ElMessage.error(error.message) // 提示错误信息    return Promise.reject(error)  &#125;)export default service\n\n登录后操作那么截止到此时，我们距离登录操作还差最后一个功能就是 登录鉴权 。\n只不过在进行 登录鉴权 之前我们得先去创建一个登录后的页面，也就是我们所说的登录后操作。\n\n创建 layout/index.vue ，写入以下代码：\n&lt;template&gt;  &lt;div class=&quot;&quot;&gt;Layout 页面&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;&#125; from &quot;vue&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;\n\n在 router/index 中，指定对应路由表：\nconst publicRoutes = [  ...&#123;    path: &quot;/&quot;,    component: () =&gt; import(&quot;@/layout/index&quot;),  &#125;,];\n\n在登录成功后，完成跳转\n// 登录后操作router.push(&quot;/&quot;);\n\n登录鉴权解决方案在处理了登陆后操作之后，接下来我们就来看一下最后的一个功能，也就是 登录鉴权\n首先我们先去对 登录鉴权 进行一个定义，什么是 登录鉴权 呢？\n\n当用户未登陆时，不允许进入除 login 之外的其他页面。\n用户登录后，token 未过期之前，不允许进入 login 页面\n\n而想要实现这个功能，那么最好的方式就是通过 路由守卫 来进行实现。\n那么明确好了 登录鉴权 的概念之后，接下来就可以去实现一下\n在 main.js 平级，创建 permission 文件\nimport router from &quot;./router/index&quot;;import &#123; useUserStore &#125; from &quot;./stores/user&quot;;const whiteList = [&quot;/login&quot;];/** * 这里舍弃了第三个参数next的用法，使用了return返回参数的用法 * 通过一个路由地址重定向到一个不同的地址，如同调用 router.push() */router.beforeEach(async (to, from) =&gt; &#123;  const userStore = useUserStore();  const token = userStore.token;  if (token) &#123;    //已登录    if (to.path === &quot;/login&quot;) &#123;      return &quot;/&quot;;    &#125; else &#123;      return true; //跳转到 to 所指向的路由    &#125;  &#125; else &#123;    //未登录    if (whiteList.includes(to.path)) &#123;      return true;    &#125; else &#123;      return &quot;/login&quot;;    &#125;  &#125;&#125;);\n","tags":["Vue3+TS后台方案"]},{"title":"编程规范解决方案之ESLint + Git Hooks","url":"/blog/2024/02/25/vue3%E5%90%8E%E5%8F%B0%E7%BB%BC%E5%90%88%E6%96%B9%E6%A1%88/1.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BESLint%20+%20Git%20Hooks%20/","content":"编程规范解决方案之 ESLint + Git Hooks本章节中讲解如何自动化的对代码进行规范，其中主要包括两大类：\n\n编码规范\ngit 规范\n\n代码检测工具 ESLint\nESLint 是一个用于识别和报告在 ECMAScript&#x2F;JavaScript 代码中发现的模式的工具，其目标是使代码更加一致并避免错误\n\n? Pick a linter / formatter config:  ESLint with error prevention only // 仅包含错误的 ESLint  ESLint + Airbnb config // Airbnb 的 ESLint 延伸规则  ESLint + Standard config // 标准的 ESLint 规则\n\n我们当前选择了 标准的 ESLint 规则 ，那么接下来我们就在该规则之下，看一看 ESLint 它的一些配置都有什么？\n打开项目中的 .eslintrc.js 文件\n// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象// 文档：https://eslint.bootcss.com/docs/user-guide/configuringmodule.exports = &#123;  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下  root: true,  // env 表示启用 ESLint 检测的环境  env: &#123;    // 在 node 环境下启动 ESLint 检测    node: true,  &#125;,  // ESLint 中基础配置需要继承的配置  extends: [&quot;plugin:vue/vue3-essential&quot;, &quot;@vue/standard&quot;],  // 解析器  parserOptions: &#123;    parser: &quot;babel-eslint&quot;,  &#125;,  // 需要修改的启用规则及其各自的错误级别  /**   * 错误级别分为三种：   * &quot;off&quot; 或 0 - 关闭规则   * &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)   * &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)   */  rules: &#123;    &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,  &#125;,&#125;;\n\n那么到这里咱们已经大致的了解了.eslintrc.js 文件，基于 ESLint 如果我们出现不符合规范的代码格式时，那么就会得到一个对应的错误。\n但是一个团队中，人员的水平高低不齐，大量的 ESLint 规则校验，会让很多的开发者头疼不已，从而大大影响了项目的开发进度。\n试想一下，在你去完成项目代码的同时，还需要时时刻刻注意代码的格式问题，这将是一件多么痛苦的事情！\n那么有没有什么办法，既可以保证 ESLint 规则校验，又可以解决严苛的格式规则导致的影响项目进度的问题呢？\n代码格式化 Prettierprettier 是什么？\n\n一个代码格式化工具\n开箱即用\n可以直接集成到 VSCode 之中\n在保存时，让代码直接符合 ESLint 标准（需要通过一些简单配置）\n\n那么这些简单配置具体指的是什么呢？\n请看下一小节《ESLint 与 Prettier 配合解决代码格式问题》\nESLint 与 Prettier 配合解决代码格式问题\n在 VSCode 中安装 prettier 插件（搜索 prettier），这个插件可以帮助我们在配置 prettier 的时候获得提示\n\n\n在项目中新建 .prettierrc 文件，该文件为 perttier 默认配置文件\n\n在该文件中写入如下配置：\n&#123;  // 不尾随分号  &quot;semi&quot;: false,  // 使用单引号  &quot;singleQuote&quot;: true,  // 多行逗号分割的语法中，最后一行不加逗号  &quot;trailingComma&quot;: &quot;none&quot;&#125;\n\n打开 VSCode 《设置面板》，在设置中，搜索 save ，勾选 Format On Save\n\n\n至此，你即可在 VSCode 保存时，自动格式化代码！\n但是！ 你只做到这样还不够！\n\n\nVSCode 而言，默认一个 tab 等于 4 个空格，而 ESLint 希望一个 tab 为两个空格\n\n如果大家的 VSCode 安装了多个代码格式化工具的化\n\nESLint 和 prettier 之间的冲突问题\n\n\n\n我们尝试在 Home.vue 中写入一个 created 方法，写入完成之后，打开我们的控制台我们会发现，此时代码抛出了一个 ESLint 的错误\n那么此时的这个问题就是 prettier 和 ESLint 的冲突问题。\n针对于这个问题我们想要解决也非常简单：\n\n打开 .eslintrc.js 配置文件\n\n在 rules 规则下，新增一条规则\n&#x27;space-before-function-paren&#x27;: &#x27;off&#x27;\n\n该规则表示关闭《方法名后增加空格》的规则\n\n重启项目\n\n\n至此我们整个的 perttier 和 ESLint 的配合使用就算是全部完成了。\n约定式提交规范在前面我们通过 prettier + ESLint 解决了代码格式的问题，但是我们之前也说过 编程规范 指的可不仅仅只是 代码格式规范 。\n除了 代码格式规范 之外，还有另外一个很重要的规范就是 git 提交规范！\n在现在的项目开发中，通常情况下，我们都会通过 git 来管理项目。只要通过 git 来管理项目，那么就必然会遇到使用 git 提交代码的场景\n当我们执行 git commit -m &quot;描述信息&quot; 的时候，我们知道此时必须添加一个描述信息。但是中华文化博大精深，不同的人去填写描述信息的时候，都会根据自己的理解来进行描述。\n所以 git 提交规范 势在必行。\n约定式提交规范要求如下：\n&lt;type&gt;[optional scope]: &lt;description&gt;[optional body][optional footer(s)]--------  翻译 -------------&lt;类型&gt;[可选 范围]: &lt;描述&gt;[可选 正文][可选 脚注]\n\n其中 &lt;type&gt; 类型，必须是一个可选的值，比如：\n\n新功能：feat\n修复：fix\n文档变更：docs\n….\n\nCommitizen 助你规范化提交代码commitizen 仓库名为 cz-cli ，它提供了一个 git cz 的指令用于代替 git commit，简单一句话介绍它：\n\n当你使用 commitizen 进行代码提交（git commit）时，commitizen 会提交你在提交时填写所有必需的提交字段！\n\n\n全局安装Commitizen\nnpm install -g commitizen@4.2.4\n\n安装并配置 cz-customizable 插件\n\n使用 npm 下载 cz-customizable\nnpm i cz-customizable@6.3.0 --save-dev\n\n添加以下配置到 package.json  中\n...  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-customizable&quot;    &#125;  &#125;\n\n\n项目根目录下创建 .cz-config.js 自定义提示文件\nmodule.exports = &#123;  // 可选类型  types: [    &#123; value: &quot;feat&quot;, name: &quot;feat:     新功能&quot; &#125;,    &#123; value: &quot;fix&quot;, name: &quot;fix:      修复&quot; &#125;,    &#123; value: &quot;docs&quot;, name: &quot;docs:     文档变更&quot; &#125;,    &#123; value: &quot;style&quot;, name: &quot;style:    代码格式(不影响代码运行的变动)&quot; &#125;,    &#123;      value: &quot;refactor&quot;,      name: &quot;refactor: 重构(既不是增加feature，也不是修复bug)&quot;,    &#125;,    &#123; value: &quot;perf&quot;, name: &quot;perf:     性能优化&quot; &#125;,    &#123; value: &quot;test&quot;, name: &quot;test:     增加测试&quot; &#125;,    &#123; value: &quot;chore&quot;, name: &quot;chore:    构建过程或辅助工具的变动&quot; &#125;,    &#123; value: &quot;revert&quot;, name: &quot;revert:   回退&quot; &#125;,    &#123; value: &quot;build&quot;, name: &quot;build:    打包&quot; &#125;,  ],  // 消息步骤  messages: &#123;    type: &quot;请选择提交类型:&quot;,    customScope: &quot;请输入修改范围(可选):&quot;,    subject: &quot;请简要描述提交(必填):&quot;,    body: &quot;请输入详细描述(可选):&quot;,    footer: &quot;请输入要关闭的issue(可选):&quot;,    confirmCommit: &quot;确认使用以上信息提交？(y/n/e/h)&quot;,  &#125;,  // 跳过问题  skipQuestions: [&quot;body&quot;, &quot;footer&quot;],  // subject文字长度默认是72  subjectLimit: 72,&#125;;\n\n使用 git cz 代替 git commit使用 git cz 代替 git commit，即可看到提示内容\n\n\n那么到这里我们就已经可以使用git cz 来代替了 git commit 实现了规范化的提交诉求了，但是当前依然存在着一个问题，那就是我们必须要通过 git cz 指令才可以完成规范化提交！\n那么如果有马虎的同事，它们忘记了使用 git cz 指令，直接就提交了怎么办呢？\n那么有没有方式来限制这种错误的出现呢？\n答案是有的！\n下一节我们来看 《什么是 Git Hooks》\n什么是 Git Hooks上一小节中我们使用了 git cz 来代替了 git commit 实现了规范化的提交诉求，但是依然存在着有人会忘记使用的问题。\n那么这一小节我们就来看一下这样的问题，我们应该如何去进行解决。\n先来明确一下我们最终要实现的效果：\n\n我们希望：\n当《提交描述信息》不符合 约定式提交规范 的时候，阻止当前的提交，并抛出对应的错误提示\n\n而要实现这个目的，我们就需要先来了解一个概念，叫做 Git hooks（git 钩子 || git 回调方法）\n也就是：**git 在执行某个事件之前或之后进行一些其他额外的操作**\n而我们所期望的 阻止不合规的提交消息，那么就需要使用到 hooks 的钩子函数。\n下面是我整理出来的所有的 hooks ，大家可以进行一下参考，其中加粗的是常用到的 hooks：\n\n\n\nGit Hook\n调用时机\n说明\n\n\n\npre-applypatch\ngit am执行前\n\n\n\napplypatch-msg\ngit am执行前\n\n\n\npost-applypatch\ngit am执行后\n不影响git am的结果\n\n\npre-commit\ngit commit执行前\n可以用git commit --no-verify绕过\n\n\ncommit-msg\ngit commit执行前\n可以用git commit --no-verify绕过\n\n\npost-commit\ngit commit执行后\n不影响git commit的结果\n\n\npre-merge-commit\ngit merge执行前\n可以用git merge --no-verify绕过。\n\n\nprepare-commit-msg\ngit commit执行后，编辑器打开之前\n\n\n\npre-rebase\ngit rebase执行前\n\n\n\npost-checkout\ngit checkout或git switch执行后\n如果不使用--no-checkout参数，则在git clone之后也会执行。\n\n\npost-merge\ngit commit执行后\n在执行git pull时也会被调用\n\n\npre-push\ngit push执行前\n\n\n\npre-receive\ngit-receive-pack执行前\n\n\n\nupdate\n\n\n\n\npost-receive\ngit-receive-pack执行后\n不影响git-receive-pack的结果\n\n\npost-update\n当 git-receive-pack对 git push 作出反应并更新仓库中的引用时\n\n\n\npush-to-checkout\n当&#96;&#96;git-receive-pack对git push做出反应并更新仓库中的引用时，以及当推送试图更新当前被签出的分支且receive.denyCurrentBranch配置被设置为updateInstead&#96;时\n\n\n\npre-auto-gc\ngit gc --auto执行前\n\n\n\npost-rewrite\n执行git commit --amend或git rebase时\n\n\n\nsendemail-validate\ngit send-email执行前\n\n\n\nfsmonitor-watchman\n配置core.fsmonitor被设置为.git/hooks/fsmonitor-watchman或.git/hooks/fsmonitor-watchmanv2时\n\n\n\np4-pre-submit\ngit-p4 submit执行前\n可以用git-p4 submit --no-verify绕过\n\n\np4-prepare-changelist\ngit-p4 submit执行后，编辑器启动前\n可以用git-p4 submit --no-verify绕过\n\n\np4-changelist\ngit-p4 submit执行并编辑完changelist message后\n可以用git-p4 submit --no-verify绕过\n\n\np4-post-changelist\ngit-p4 submit执行后\n\n\n\npost-index-change\n索引被写入到read-cache.c do_write_locked_index后\n\n\n\nPS：详细的 HOOKS介绍 可点击这里查看\n整体的 hooks 非常多，当时我们其中用的比较多的其实只有两个：\n\n\n\nGit Hook\n调用时机\n说明\n\n\n\npre-commit\ngit commit执行前它不接受任何参数，并且在获取提交日志消息并进行提交之前被调用。脚本git commit以非零状态退出会导致命令在创建提交之前中止。\n可以用git commit --no-verify绕过\n\n\ncommit-msg\ngit commit执行前可用于将消息规范化为某种项目标准格式。还可用于在检查消息文件后拒绝提交。\n可以用git commit --no-verify绕过\n\n\n简单来说这两个钩子：\n\ncommit-msg：可以用来规范化标准格式，并且可以按需指定是否要拒绝本次提交\npre-commit：会在提交前被调用，并且可以按需指定是否要拒绝本次提交\n\n而我们接下来要做的关键，就在这两个钩子上面。\n使用 husky + commitlint 检查提交描述是否符合规范要求我们就使用 git hooks 来去校验我们的提交信息。要完成这么个目标，那么我们需要使用两个工具：\n\ncommitlint：用于检查提交信息\n\nhusky：是git hooks工具\n\n\n注意：**npm 需要在 7.x 以上版本！！！！！**\n那么下面我们分别来去安装一下这两个工具：\ncommitlint\n安装依赖：\nnpm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4\n\n创建 commitlint.config.js 文件\necho &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js\n\n打开 commitlint.config.js ， 增加配置项（ config-conventional 默认配置点击可查看 ）：\nmodule.exports = &#123;  // 继承的规则  extends: [&quot;@commitlint/config-conventional&quot;],  // 定义规则类型  rules: &#123;    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内    &quot;type-enum&quot;: [      2,      &quot;always&quot;,      [        &quot;feat&quot;, // 新功能 feature        &quot;fix&quot;, // 修复 bug        &quot;docs&quot;, // 文档注释        &quot;style&quot;, // 代码格式(不影响代码运行的变动)        &quot;refactor&quot;, // 重构(既不增加新功能，也不是修复bug)        &quot;perf&quot;, // 性能优化        &quot;test&quot;, // 增加测试        &quot;chore&quot;, // 构建过程或辅助工具的变动        &quot;revert&quot;, // 回退        &quot;build&quot;, // 打包      ],    ],    // subject 大小写不做校验    &quot;subject-case&quot;: [0],  &#125;,&#125;;\n\n注意：确保保存为 UTF-8 的编码格式，否则可能会出现以下错误：\n接下来我们来安装 husky\nhusky\n安装依赖：\nnpm install husky@7.0.1 --save-dev\n\n启动 hooks ， 生成 .husky 文件夹\nnpx husky install\n\n在 package.json 中生成 prepare 指令（ 需要 npm &gt; 7.0 版本 ）\nnpm set-script prepare &quot;husky install&quot;\n\n执行 prepare 指令\nnpm run prepare\n\n添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx --no-install commitlint --edit &quot;$1&quot; 指令\nnpx husky add .husky/commit-msg &#x27;npx --no-install commitlint --edit &quot;$1&quot;&#x27;\n\n至此， 不符合规范的 commit 将不再可提交：\nPS F:\\xxxxxxxxxxxxxxxxxxxxx\\imooc-admin&gt; git commit -m &quot;测试&quot;⧗   input: 测试✖   subject may not be empty [subject-empty]✖   type may not be empty [type-empty]✖   found 2 problems, 0 warningsⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlinthusky - commit-msg hook exited with code 1 (error)\n\n那么至此，我们就已经可以处理好了 强制规范化的提交要求，到现在 不符合规范的提交信息，将不可在被提交！\n那么到这里我们的 规范化目标 就完成了吗？\n当然没有！\n现在我们还缺少一个 规范化的处理 ，那就是 代码格式提交规范处理！\n通过 pre-commit 检测提交时代码规范在 ESLint 与 Prettier 配合解决代码格式问题 的章节中，我们讲解了如何处理 本地！代码格式问题。\n但是这样的一个格式处理问题，他只能够在本地进行处理，并且我们还需要 手动在 VSCode 中配置自动保存 才可以。那么这样就会存在一个问题，要是有人忘记配置这个东西了怎么办呢？他把代码写的乱七八糟的直接就提交了怎么办呢？\n所以我们就需要有一种方式来规避这种风险。\n那么想要完成这么一个操作就需要使用 husky 配合 eslint 才可以实现。\n我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint --ext .js,.vue src 指令来去进行相关检测：\n\n执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; 添加 commit 时的 hook （npx eslint --ext .js,.vue src 会在执行到该 hook 时运行）\n\n该操作会生成对应文件 pre-commit：\n\n关闭 VSCode 的自动保存操作\n\n修改一处代码，使其不符合 ESLint 校验规则\n\n执行 提交操作 会发现，抛出一系列的错误，代码无法提交\nPS F:\\xxxxxxxxxxxxxxxxxxx\\imooc-admin&gt; git commit -m &#x27;test&#x27;F:\\xxxxxxxxxxxxxxxx\\imooc-admin\\src\\views\\Home.vue  13:9  error  Strings must use singlequote  quotes✖ 1 problem (1 error, 0 warnings)  1 error and 0 warnings potentially fixable with the `--fix` option.husky - pre-commit hook exited with code 1 (error)\n\n想要提交代码，必须处理完成所有的错误信息\n\n\n那么到这里位置，我们已经通过 pre-commit 检测到了代码的提交规范问题。\nlint-staged 自动修复格式错误在上一章中我们通过 pre-commit 处理了 检测代码的提交规范问题，当我们进行代码提交时，会检测所有的代码格式规范 。\n但是这样会存在两个问题：\n\n我们只修改了个别的文件，没有必要检测所有的文件代码格式\n它只能给我们提示出对应的错误，我们还需要手动的进行代码修改\n\n那么想要处理这两个问题，就需要使用另外一个插件 lint-staged ！\nlint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送\nlint-staged 无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了\n\n修改 package.json 配置\n&quot;lint-staged&quot;: &#123;    &quot;src/**/*.&#123;js,vue&#125;&quot;: [      &quot;eslint --fix&quot;,      &quot;git add&quot;    ]  &#125;\n\n如上配置，每次它只会在你本地 commit 之前，校验你提交的内容是否符合你本地配置的 eslint规则(这个见文档 ESLint )，校验会出现两种结果：\n\n如果符合规则：则会提交成功。\n如果不符合规则：它会自动执行 eslint --fix 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码。\n\n\n修改 .husky/pre-commit 文件\n#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;npx lint-staged\n\n再次执行提交代码\n\n发现 暂存区中 不符合 ESlint 的内容，被自动修复\n\n\n","tags":["Vue3+TS后台方案"]},{"title":"webpack基础","url":"/blog/2023/06/10/webpack/webpack%E5%9F%BA%E7%A1%80/","content":"初识 webpack\n本质上，webpack 是一个用于现代 JavaScript 应用程序的 _静态模块打包工具_。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 _bundles_，它们均为静态资源，用于展示你的内容\n\n这里需要提到开发环境与生产环境的差异：\n开发：\n\n需要模块化、帮助更好的开发\n会使用一些 ES 新语法和框架特殊写法\n\n生产：\n\n浏览器自身无法解析模块化\n浏览器只认识 html、css、js，甚至有些浏览器不识别新的 js 语法\n\n而 webpack 作为构建工具，核心工作就是为了解决开发环境与生产环境的矛盾\n那么构建工具到底帮我们做了什么？\n\n编译浏览器无法理解的东西 —— ES6、TS、Vue 语法等（配合插件、loader）\n代替一些人工操作—— 文件合并和拆分 、 图片压缩 、资源处理等\n辅助开发 —— 开发模式\n\nwebpack 基础配置entry:必须项，以哪个文件开始\noutput:必须项，最终产出 js 的位置\nmode: webpack4 后必填, 告知 webpack 使用相应模式的内置优化\ndevServer: 开发模式配置\nmodule: loader 编写的地方\nplugins：插件配置\noptimization：优化相关\nresolve: 提供一些简化功能\n1.安装 webpack\nnpm i webpack webpack-cli -g //默认为webpack5\n\n如果是局部安装且在项目中配置：\n//package.json&quot;scripts&quot;:&#123;    &quot;dev&quot;: &quot;webpack&quot;  //这时候就是使用局部安装的webpack&#125;\n\n2.基础打包配置\n项目根目录下新建webpack.config.js并配置：\n//因为webpack是用node编写的，编译文件请使用commonjs规范module.exports = &#123;    mode: &quot;production&quot;, //打包模式 none || development || production    //entry:&quot;./app.js&quot; //单入口    //多入口写法    entry: &#123;    \tapp:&quot;./app.js&quot;,    \t//app2:&quot;./app2.js&quot;,\t&#125;,    output: &#123;        path: __dirname + &quot;./dist&quot;,        filename: &quot;[name].[fullhash:4].bundle.js&quot;    &#125;    optimization: &#123;&#125;,    devServer: &#123;&#125;,    resolve:&#123;&#125;    modules: &#123;    \trules: [    \t\t//每个对象都是一个loader    \t\t&#123;    \t\t\ttest:/\\.js/,    \t\t\tloader:...\t\t\t&#125;    \t]\t&#125;,    plugins: [],&#125;\n\nWebpack 处理 jsE6 转化：babel-loader\n代码规范： eslint\n代码的分割和打包: webpack 自身的核心功能\nbabel-loader 的配置1.安装 babel-loader、@babel&#x2F;core（实际起编译作用）\nnpm install babel-loader @babel/core --save-dev\n\n2.配置webpack.config.js\nmodule.exports = &#123;    ...,    module: &#123;    \trules:[    \t\t&#123;    \t\t\ttest: /\\.js/,    \t\t\t//loader:&quot;babel-loader&quot;, //对指定类型文件的处理方案    \t\t\t//如果需要对loader进行配置，则使用use    \t\t\tuse:&#123;    \t\t\t\tloader: &quot;babel-loader&quot;, //如果loader属性传入数组，则从后往前执行loader    \t\t\t\toptions: &#123;    \t\t\t\t\t//options内部的配置就是各个loader都不同了\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;    \t]\t&#125;,&#125;\n\n重新执行编译，这个时候我们会发现 ES6 的语法并没有编译为 ES5。\n打包前：\nlet num = 1;console.log(num);\n\n打包后：\neval(  &quot;let num = 1;\\r\\nconsole.log(num);\\r\\n\\n\\n//# sourceURL=webpack://pack/./app.js?&quot;);\n\n这个时候我就可以通过安装预设环境@babel/preset-env，然后配置 preset：\n...use:&#123;    loader: &quot;babel-loader&quot;, //如果loader属性传入数组，则从后往前执行loader    options: &#123;    \tpresets:[            [            \t&#x27;@babel/preset-env&#x27;,                &#123;                    targets:&#123;                        browsers:[                            &quot;&gt; 1%&quot;, //市场占有率                            &quot;last 2 versions&quot;, //厂商的最近两个版本                            &quot;not ie&lt;=8&quot;                        ]                    &#125;                &#125;            ]        ]\t&#125;&#125;...\n\n这时候就可以看到打包后的文件为 ES5 的语法了\neval(  &quot;var num = 1;\\nconsole.log(num);\\n\\n//# sourceURL=webpack://pack/./app.js?&quot;);\n\n如果配置太多，可以在根目录新建文件babel.config.js，将 options 中的配置在里面暴露可以实现同样的效果\nmodule.exports = &#123;  presets: [    [      &quot;@babel/preset-env&quot;,      &#123;        targets: &#123;          browsers: [            &quot;&gt; 1%&quot;, //市场占有率            &quot;last 2 versions&quot;, //厂商的最近两个版本            &quot;not ie&lt;=8&quot;,          ],        &#125;,      &#125;,    ],  ],&#125;;\n\neslint 的工作在 webpack5 中，eslint-loader 已停止更新， 我们在这里选择eslint-webpack-plugin插件\n1.安装插件\nnpm install eslint eslint-webpack-plugin --save-dev\n\n2.配置webpack.config.js\nconst EslintPlugin = require(&#x27;eslint-webpack-plugin&#x27;);module.exports = &#123;    ...,    plugins: [    \tnew EslintPlugin();    ]&#125;\n\n这个时候也可以像 loader 一样，将配置写在一个单独的文件eslintrc.js中\nmodule.exports = &#123;  //指定一个配置文件可以被基础配置中的已启用的规则继承(默认开启的基本规则，可在下方rules处覆盖)  extends: [    //继承现成的规范，比如eslint-config-standard、eslint-config-airbnb    &quot;eslint-config-standard&quot;,    &quot;plugin:vue/strongly-recommanded&quot;,  ],  env: &#123;    browser: true, //主要是帮助判断使用到的全局变量是否存在于该环境    es2021: true,  &#125;,  //可以提供一些额外的rules，比如vue  plugins: [    &quot;vue&quot;, //可以省略插件名称中的 eslint-plugin- 前缀  ],  parserOptions: &#123;    ecmaVersion: 2015,    sourceType: &quot;module&quot;, //ES6-module  &#125;,  rules: &#123;    &quot;no-console&quot;: &quot;off&quot;,  &#125;,&#125;;\n\ncss 与资源文件的处理css 的处理webpack 只认 js，所以如果在 js 中引入的 css 是无法打包成功的。\n1.安装插件\nnpm install  css-loader style-loader --save-dev\n\n2.配置webpack.config.js\nmodules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;                test: /\\.css$/i,                use: [&quot;style-loader&quot;, &quot;css-loader&quot;],      \t\t&#125;,    \t]\t&#125;&#125;\n\n这个时候 css 就会写入 js 文件中，并通过 style 标签注入 html 文件\n打包前：\n/*app.css*/body &#123;  padding: 0px;&#125;\n\n打包后：\n//app.6fecbundle.js...[module.id, `body &#123;\\r\\n    padding: 0px;\\r\\n&#125;`, \\&quot;\\&quot;]...\n\n如果我们想将 CSS 提取到单独的文件中，需要安装 mini-css-extract-plugin插件，然后配置：\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);modules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;                test: /\\.css$/i,                use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      \t\t&#125;,    \t]\t&#125;&#125;\n\nsass、less 的处理这里以 sass 为例，安装sass-loader, 加载 Sass&#x2F;SCSS 文件并将他们编译为 CSS\nnpm install sass-loader sass --save-dev\n\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);modules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;                test: /\\.css$/i,                use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;,&quot;sass-loader&quot;],      \t\t&#125;,    \t]\t&#125;&#125;\n\n运行 webpack打包生成：\n/*!*****************************************************************************************************!*\\  !*** css ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./style.scss ***!  \\*****************************************************************************************************/body &#123;  color: red;&#125;\n\n但是这里有个问题，会发现 css 代码没有压缩，就算将webpack.config.js的mode设置为 production,也只是去掉注释…..\ncss 代码的压缩与优化安装 css-minimizer-webpack-plugin，并配置\nnpm install css-minimizer-webpack-plugin --save-dev\n\nconst CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);modules.exports = &#123;    ...,    optimization: &#123;        minimizer: [          new CssMinimizerPlugin(),        ],  \t&#125;,&#125;\n\n可以发现代码已经成功压缩了：\nbody &#123;  color: red;&#125;\n\n资源文件的处理在 webpack 5 之前，通常使用：\n​ row-loader将文件导入为字符串\n​ url-loader将文件作为 data URI 内联到 bundle 中(base64)\n​ file-loader将文件发送到输出目录\n更多细节参考：https://www.webpackjs.com/guides/asset-modules/\n而 webpack5 则自带了对资源文件的支持：\n\nasset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\nasset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\nasset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\nasset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n\nmodules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;        \t\ttest: /\\.(png|svg|jpg|jpeg|gif)$/i,\t\t\t\ttype: &#x27;asset&#x27;,  //默认小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型      \t\t\t//如果想要自定义打包base64的文件大小范围：    \t\t\tparser: &#123;         \t\t\tdataUrlCondition: &#123;           \t\t\t\tmaxSize: 4 * 1024 // 4kb         \t\t\t&#125;       \t\t\t&#125;,                generator: &#123;         \t\t\tfilename: &#x27;[name].[fullhash:4][ext]&#x27;       \t\t\t&#125;\t\t\t&#125;,    \t]\t&#125;&#125;\n\nhtml 的处理html 做什么？\n\n给 webpack 提供一个 html 模板给，复用固定内容\n打包的时候再生成一个 html\n打包出来的 html 自动引入 js\n\n对于 html 的处理使用插件、而不是loader\n\n为什么不用 loader?\n这里需要在加强一下 loader 的概念，当非 js 的代码引入到 js 文件，需要使用 loader 去帮助 webpack 识别， 而 html 文件几乎是不会存在引入 js 的情况。\n\n\n安装插件\n\nnpm i html-webpack-plugin --save-dev\n\n\nwebpack.config.js的基本配置\n\n...,const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    ...,    plugins: [    \tnew HtmlWebpackPlugin(&#123;    \t\t/*基础配置*/    \t\ttemplate: &quot;./index.html&quot;,    \t\tfilename: &#x27;index_bundle.html&#x27;    \t\t/*取消默认压缩，便于开发环境调试*/    \t\tminify: &#123;    \t\t\tcollapeWhitespace: false,    \t\t\tremoveComments: false,    \t\t\tremoveAttributeQuotes: false\t\t\t&#125;,\t\t\t/*指定js文件的引入位置*/\t\t\tinject:true,  //true || &#x27;head&#x27; || &#x27;body&#x27; || false\t\t&#125;),  \t]&#125;\n\n打包后，入口 js 文件就会自动引入 html 文件：\n&lt;!-- index_bundle.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;    &lt;title&gt;webpack&lt;/title&gt;    &lt;script defer=&quot;defer&quot; src=&quot;app.b77abundle.js&quot;&gt;&lt;/script&gt;    &lt;link href=&quot;app.css&quot; rel=&quot;stylesheet&quot; /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n多入口的情况：\n...,const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    entry:&#123;        &quot;app1&quot;: &quot;./index.html&quot;,        &quot;app2&quot;: &quot;./index2.html&quot;,    &#125;    ...,    plugins: [    \tnew HtmlWebpackPlugin(&#123;    \t\ttemplate: &quot;./index.html&quot;,    \t\tfilename: &#x27;index.html&#x27;,    \t\tchunks: [&quot;app&quot;],\t\t&#125;),        new HtmlWebpackPlugin(&#123;    \t\ttemplate: &quot;./index2.html&quot;,    \t\tfilename: &#x27;index2.html&#x27;,    \t\tchunks: [&quot;app2&quot;],\t\t&#125;)  \t]&#125;\n\n编写自己的模板及更多细节参考：https://www.npmjs.com/package/html-webpack-plugin\n开发模式安装插件webpack-dev-server\nnpm install webpack-dev-server --save-dev\n\n常用配置//webpack.config.js...,module.exports = &#123;    devServer: &#123;        port: 3000,    \thot: true,  //热更新        /*由webpack-dev-server 开启的node服务来代替我们发送接口请求，避免跨域*/        proxy: &#123;            &#x27;/api&#x27;: &#123;                /*                \t对 /api/users 的请求会将请求代理到 http://localhost:3000/api/users               \t \t不过在控制台中仍然显示的http://localhost:8000/api/hello                */        \t\ttarget: &#x27;http://localhost:3000&#x27;,        \t\tpathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,      \t\t&#125;,        &#125;,         headers: &#123;            //设置响应头        &#125;    &#125;&#125;\n\nwebpack-dev-server 工作原理核心：express + webpack-dev-middleware\n安装：\nnpm install webpack-dev-middleware --save-devnpm install express\n\n原理模拟：\n//mydev.jsconst express = require(&quot;express&quot;);const webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);const webpack = require(&quot;webpack&quot;);const config = reqire(&quot;./webpack.config.js&quot;);/*将配置文件传入webpack方法*/const dist = webpack(config);/*创建express服务*/const app = express();/*注册中间件*/app.use(webpackDevMiddleware(dist));/*挂载服务*/app.listen(3000);\n\n执行node myDev.js就可以实现打包效果。\n\nsource-map当代码出现错误时，source-map 帮助我们定位到打包前的初始代码位置\n//webpack.config.js...,module.exports = &#123;    /*    \teval-cheap-source-map : 开发环境的最佳选择    \tnone: 生产环境    */\tdevTool:&#x27;eval-cheap-source-map&#x27; //&#125;\n","tags":["webpack"]},{"title":"loader的本质","url":"/blog/2023/06/12/webpack/loader%E7%9A%84%E6%9C%AC%E8%B4%A8/","content":"本质\nLoader 本质是一个方法，该方法接受到要处理的资源的内容，处理完后给出内容，作为打包结果\n\n这里手写一个简易的 css-loader 为例：\n//index.jsmodules.exports = function (content) &#123;  console.log(typeof content); //string  let handledContent = content.replace(&quot;0&quot;, &quot;1&quot;);  return handledContent;&#125;;\n\n将自己写的 loader 添加到 webpack 配置中：\nmodule.exports = &#123;  \t...,    module:&#123;        rules:[           ...,            &#123;                test: /\\.css$/i,                use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;,&quot;./my-loader/index.js],      \t\t&#125;,        ]    &#125;,&#125;\n\n打包前：\nbody &#123;  padding: 0px;&#125;\n\n打包后：\nbody &#123;  padding: 1px;&#125;\n\n对应的类型文件给到对应的 loader，然后通过特定的方法去处理，这就是 loader 编译的本质~\n各种语言处理所以基本上各种语言处理都可以看成： 为该语言编写 loader → 配置该 loader\n这里以 typescript 为例，我们最终的目的是要将 TS 的语法转为 JS。\n1.安装相关的包\nnpm install typescript ts-loader --save-dev\n\n2.配置webpack.config.js\nmodule.exports = &#123;  \t...,    module:&#123;        rules:[           \t&#123;    \t\t\ttest: /\\.tsx?$/i,    \t\t\tuse: &#123;    \t\t\t\tloader:&quot;ts-loader&quot;\t\t\t\t&#125;\t\t\t&#125;        ]    &#125;,&#125;\n\n3.在根目录新建tsconfig.json\n&#123;\t...&#125;\n\n4.新建 ts 文件\n//demo.tslet muName: string = &quot;leihy&quot;;console.log(muName);\n\n在入口文件 app.js 中引入该文件并执行打包：\n//app.f378bundle.jsvar muName = &quot;leihy&quot;;console.log(muName);\n\n可以看到是已经打包成功了，以后咱们无论是使用了什么新语法只需要去了解对应的 loader 用法并配置，问题就迎刃而解了。\n","tags":["webpack"]},{"title":"webpack实战","url":"/blog/2023/06/17/webpack/webpack%E5%AE%9E%E6%88%98/","content":"环境为什么需要区分环境?\n生产模式：\n\n需要：代码压缩、tree-shaking、代码混淆等\n不需要：详细的 source-map、开启开发模式\n\n开发模式则相反。\n区分要点：\n\n根据不同环境进行不同的打包，一般在 process.env 中设置\n有的时候需要在 js 代码中获取环境，可以借助插件完成\n\n实战配置提取\n将生产与开发相同的配置提取出来到build/webpack.base.config.js\nconst EslintPlugin = require(&quot;eslint-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  entry: &#123;    app: &quot;./app.js&quot;,    // app2:&quot;./app2.js&quot;,  &#125;,  output: &#123;    path: __dirname + &quot;/dist&quot;,    filename: &quot;[name].[chunkhash:4].bundle.js&quot;,  &#125;,  resolve: &#123;    alias: &#123;      &quot;@css&quot;: &quot;/css&quot;,    &#125;,    extensions: [&quot;.js&quot;],  &#125;,  module: &#123;    rules: [      &#123;        test: /\\.js/,        use: &#123;          loader: &quot;babel-loader&quot;,          options: &#123;&#125;,        &#125;,      &#125;,      &#123;        test: /\\.tsx?/,        use: &#123;          loader: &quot;ts-loader&quot;,        &#125;,      &#125;,      &#123;        test: /\\.css$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      &#125;,      &#123;        test: /\\.scss$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;],      &#125;,      &#123;        test: /\\.(png|svg|jpg|jpeg|gif)$/i,        type: &quot;asset&quot;,        generator: &#123;          filename: &quot;[name].[chunkhash:4][ext]&quot;,        &#125;,        parser: &#123;          dataUrlCondition: &#123;            maxSize: 2 * 1024, // 4kb          &#125;,        &#125;,      &#125;,    ],  &#125;,  plugins: [    // new EslintPlugin()    new MiniCssExtractPlugin(&#123;      filename: &quot;./css/[name].[chunkhash:4].css&quot;,    &#125;),    new HtmlWebpackPlugin(&#123;      template: &quot;./index.html&quot;,      filename: &quot;index.html&quot;,      minify: &#123;        collapeWhitespace: false,        removeComments: false,        removeAttributeQuotes: false,      &#125;,    &#125;),  ],  optimization: &#123;    minimizer: [new CssMinimizerPlugin()],    splitChunks: &#123;      chunks: &quot;all&quot;, //有效值为 all，async 和 initial      cacheGroups: &#123;        vendor: &#123;          test: /[\\\\/]node_modules[\\\\/]/,          name: &quot;vendor&quot;,          minChunks: 1,          chunks: &quot;all&quot;,        &#125;,        commons: &#123;          name: &quot;commons&quot;,          chunks: &quot;initial&quot;,          minChunks: 2,          minSize: 0,        &#125;,      &#125;,    &#125;,    runtimeChunk: &#123;      name: &quot;runtime&quot;,    &#125;,  &#125;,&#125;;\n\n建立开发配置build/webpack.dev.config.js\nconst base = require(&quot;./webpack.base.config&quot;);/*安装base的文件需要安装webpack-merge*/const &#123; merge &#125; = require(&quot;webpack-merge&quot;);module.exports = merge(base, &#123;  mode: &quot;development&quot;,  devServer: &#123;    port: 8000,    hot: true,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:3000&quot;,        pathRewrite: &#123; &quot;^/api&quot;: &quot;&quot; &#125;,      &#125;,    &#125;,    headers: &#123;      &quot;X-Custom-Foo&quot;: &quot;bar&quot;,    &#125;,  &#125;,  devTool: &quot;eval-cheap-source-map&quot;,&#125;);\n\n建立生产配置build/webpack.prod.config.js\nconst base = require(&quot;./webpack.base.config&quot;);const &#123; merge &#125; = require(&quot;webpack-merge&quot;);module.exports = merge(base, &#123;  mode: &quot;production&quot;,&#125;);\n\n获取环境信息：NODE_ENV//package.json&#123;    &quot;scripts&quot;: &#123;        //传值        &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack --config build/webpack.config.dev.js&quot;,\t\t&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.prod.js&quot;  \t&#125;,&#125;//webpack.config.dev.jsconst env = process.env.NODE_ENV //development//webpack.config.prod.jsconst env = process.env.NODE_ENV //production\n\n–envwebpack 特有的属性，需要配置文件暴露一个函数，作了解\n//package.json&#123;    &quot;scripts&quot;: &#123;        //传值\t\t&quot;build&quot;: &quot;cross-env webpack --config build/webpack.config.prod.js --env production&quot;  \t&#125;,&#125;//webpack.config.build.js//使用函数就可以直接拿到接收module.exports = function(env) &#123;    console.log(env) //&#123;..., production:true &#125;    return  merge(base(env), &#123;  //base也要改造成导出一个函数    \tmode:&#x27;production&#x27;,\t&#125;)&#125;\n\n\n上面的两种方法，也只能在配置文件中拿到环境变量，如果想在业务代码中获取环境变量该如何做？\n\n可以使用 webpack 自带的插件DefinePlugin:\n//对应环境的配置文件，比如webpack.config.prod.js...,plugins: [    new webpack.DefinePlugin(&#123;  \t\tVERSION: JSON.stringify(&#x27;5fa3b9&#x27;)  //这里就可以换从环境变量\t&#125;)]//app.34rf.jsconsole.log(&#x27;5fa3b9&#x27;)  //打包前为console.log(VERSION)\n\n打包结果分析\n官方方案：打包时加上–json，将输出的结果分析 json 放到官方进行分析\nwebpack --config ./webpack.prod.config.js --json&gt;stats.json\n\n分析网站: webpack.github.io&#x2F;analyse&#x2F;\n\nwebpack-bundle-analyzer\n\n\n","tags":["webpack"]},{"title":"webpack的技巧性配置","url":"/blog/2023/06/15/webpack/webpack%E6%8A%80%E5%B7%A7%E6%80%A7%E9%85%8D%E7%BD%AE/","content":"hash 值的意义\n浏览器加载了文件后会缓存资源，每次去加载时如果发现文件名一样就会直接使用缓存资源，这就会导致我们重新打包后的文件如果跟之前同名，就会出现浏览器还是读取的以前缓存的问题。\n\n如果我们每次为生成的文件名中附带当次打包的 hash 值，就不会再出现上述情况。\noutput: &#123;    path:__dirname + &quot;/dist&quot;,    filename: &quot;[name].[fullhash:4].bundle.js&quot;&#125;\n\n但是这样会产生其他问题，比如我们现在有分离出来的 js 文件：\n|-dist  |-app.6554.bundle.js  |-index_bundle.html  |-commons.6554.bundle.js  |-vendor.6554.bundle.js\n\n如果我们修改了其中某一个文件的内容，就会导致所有的文件被重新打包生成，不利于浏览器及 webpack 打包时利用未修改的文件\n缓存。\n这时我们可以配置:\n/*将所有的fullhash改为chunkhash*/output: &#123;    path:__dirname + &quot;/dist&quot;,    filename: &quot;[name].[chunkhash:4].bundle.js&quot;&#125;\n\n这时我们发现每个 js 文件生成的 hash 值都不一样了：\n|-dist  |-app.bffb.bundle  |-index_bundle.html  |-runtime.1c33.bundle  |-vendor.2aec.bundle\n\n并且再修改某个独立 chunk 文件的内容打包后发现不会再对每个文件的 hash 值进行改变了。\nresolve这些选项能设置模块如何被解析\n\nalias-别名， 提供路径的简写\n//webpack.config.jsconst path = require(&quot;path&quot;);module.exports = &#123;  //...  resolve: &#123;    alias: &#123;      &quot;@css&quot;: path.resolve(__dirname, &quot;src/image&quot;), //    &#125;,  &#125;,&#125;;\n\n在项目内就可以使用路径简写：\nimport variable from &quot;@css/style.css&quot;;\n\nextensions - 扩展省略， 定义可省略的扩展名\n\n\nresolve: &#123;    ...,    extensions: [&#x27;.js&#x27;, &#x27;.json&#x27;],&#125;,\n\n​ 在项目内就可以引用文件时就可以省略指定的文件后缀：\nimport a from &quot;./a&quot;; //a.js\n\nrequire.context批量引入指定文件夹下的所有文件\n/* 语法 */require.context(  directory, //目录  false, // true || false 是否引入子文件夹的内容 ， 可选  /.js/, //，匹配规则，可选  sync //可选);\n\n/* 实际应用 */const cache = &#123;&#125;;function importAll(r) &#123;  r.keys().forEach((key) =&gt; (cache[key] = r(key)));&#125;importAll(require.context(&quot;../components/&quot;, true, /\\.js$/));\n\n应用场景？\ndist 文件分层以 css 为例，只需要将单独分离文件的配置处加上&#x2F;css 就可以实现\nnew MiniCssExtractPlugin(&#123;     filename:&#x27;/css/[name].[chunkhash:4].css&#x27;&#125;),\n\n其他同理。\n","tags":["webpack"]},{"title":"webpack的技巧性配置","url":"/blog/2023/06/14/webpack/%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/","content":"单入口文件的处理\n单入口意味着所有代码在一个文件里，这样会导致代码过大，所以我们需要把一些不是马上用到并且体积过大的代码拆分出来，以加快首屏渲染速度\n\n这里以引入loadsh为例子：\nimport _ from &quot;lodash&quot;;const element = document.createElement(&quot;div&quot;);element.innerHTML = _.join([&quot;Hello&quot;, &quot;webpack&quot;], &quot; &quot;);document.body.appendChild(element);const initEle = document.createElement(&quot;div&quot;);initEle.innerHTML = &quot;init&quot;;document.body.appendChild(initEle);\n\n通过 webpack 打包后发现 dist 文件中还是只有一个 js 文件，并且包含了loadsh的海量代码。\n|-dist\t|-app.c9d4bundle.js\t|-index_bundle.html\n\n如果我们在页面上渲染内容，就会等到 lodash 中的所有代码加载完毕才会显示 init 文本。\n现在，我们不再静态导入 lodash，而是通过动态异步导入来分离出一个异步 chunk：\nfunction getComponent() &#123;  // 使用 import 引入lodash，其实是一个promise  return import(&quot;lodash&quot;).then((&#123; default: _ &#125;) =&gt; &#123;    const element = document.createElement(&quot;div&quot;);    element.innerHTML = _.join([&quot;Hello&quot;, &quot;webpack&quot;], &quot; &quot;);    return element;  &#125;);&#125;getComponent().then((component) =&gt; &#123;  document.body.appendChild(component);&#125;);const initEle = document.createElement(&quot;div&quot;);initEle.innerHTML = &quot;init&quot;;document.body.appendChild(initEle);\n\n打包后我们发现 lodash 的代码单独分离出来了一个 js 文件：\n|-dist  |-app.9703bundle  |-index_bundle.html  |-vendors-node_modules_lodash_lodash_js.5e1cbundle.js\n\n经过优化后，‘init’字符串就会被先渲染出来，大大提高了首屏渲染速度。\n多入口文件的处理\n多入口的问题主要是重复加载同一段逻辑代码\n\n如果我们在两个 js 入口文件导入了相同的 js 文件。那么在打包后会发现同样的代码会在两个 js 文件中重复出现。\n如何优化：\n//webpack.config.js...module.exports = &#123;    ...,    optimization:&#123;    \tsplitChunks:&#123;    \t\tchunks:&quot;all&quot;,   //有效值为 all，async 和 initial    \t\tminChunks: 2, //拆分前必须共享模块的最小 chunks 数    \t\tminSize:0,   //生成 chunk 的最小体积（以 bytes 为单位）\t\t&#125;\t&#125;&#125;\n\n在打包后发现共同导入的 js 文件单独生成了一个 chunk：\n|-dist  |-app.6554.bundle.js  |-app2.6554.bundle.js  |-index_bundle.html  |-a_js.6554.bundle.js  //单独生成\n\n并且在入口文件中分别引入该 js 文件从而实现一份代码的复用：\n...webpack_require__(/*! ./a.js */ \\&quot;./a.js\\&quot;)...\n\n分离第三方库与运行代码//webpack.config.js...module.exports = &#123;    ...,    optimization:&#123;    \tsplitChunks:&#123;    \t\tchunks:&quot;all&quot;,  \t\t\tcacheGroups: &#123;    \t\t\t/** 第三方库 **/        \t\tvendor: &#123;                  \ttest: /[\\\\/]node_modules[\\\\/]/,                  \tname: &#x27;vendor&#x27;,    \t\t\t\tminChunks:1,   \t \t\t\t\tchunks:&quot;all&quot;,        \t\t&#125;,    \t\t\t/** 通用业务代码 **/    \t\t\tcommons: &#123;                    name: &#x27;commons&#x27;,                    chunks: &#x27;initial&#x27;,                    minChunks: 2,                    minSize: 20000,      \t\t\t&#125;,\t\t&#125;,        /** webpack运行代码 **/        runtimeChunk: &#123;      \t\tname: &#x27;runtime&#x27;,    \t&#125;,\t&#125;&#125;\n\n打包出来的文件：\n|-dist  |-app.6554.bundle.js  |-index_bundle.html  |-a_js.6554.bundle.js  //单独生成  |-commons.随机四位hash.bundle.js  //新版本的  |-vendor.随机四位hash.bundle.js  //单独生成\n\n我们最终要分出来的文件有：\n\n单入口：runtime + vendor + 核心业务 + 异步模块\n多入口：runtime + vendor + 每个入口的核心业务 + common\n\n","tags":["webpack"]}]