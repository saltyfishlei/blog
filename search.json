[{"title":"前端变量的使用和原理","url":"/blog/2023/12/15/%E6%90%9E%E6%87%82%E5%89%8D%E7%AB%AF%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/","content":"不同的环境使用不同的服务器\n开发环境请求的是公司局域网的服务器\n生产环境请求的是真正的服务器，比如云服务\n使用使用 .env.环境名字 定义，运行命令的时候指定环境\nVite + vue3 项目存值：VITE_变量名 &#x3D; xxx\n//.envVITE_GLOBAL = global; //都可以使用//.env.developmentVITE_BASE_URL = 192; //开发环境//.env.productionVITE_BASE_URL = 112; //生产环境-build后的文件内容\n\n取值：import.meta.env.VITE_变量名\nconsole.log(import.meta.env.VITE_BASE_URL)  //生产为112、开发时为192console.log(import.meta.env.VITE_GLOBAL) //都会存在为global\n\nvue-cli 项目 (Webpack + vue2 )0存值：VUEAPP变量名 &#x3D; xxx\n//.envVUE_APP_GLOBAL = global  //都可以使用//.env.developmentVUE_APP_BASE_URL = 192   //开发环境//.env.productionVUE_APP_BASE_URL = 112  //生产环境-build后的文件内容\n\n取值：process.env.VUEAPP变量名\nconsole.log(process.env.VUE_APP_BASE_URL); //生产为112、开发时为192console.log(import.meta.env.VUE_APP_GLOBAL); //都会存在为global\n\n指定环境vite//package.json&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite&quot;, //读取.env.development    &quot;build&quot;: &quot;vite build&quot;, //读取.env.production    &quot;test&quot;: &quot;vite --mode=test&quot; //读取.env.test  &#125;&#125;\n\nwebpack//package.json&#123;  &quot;scripts&quot;: &#123;    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, //读取.env.development    &quot;build&quot;: &quot;vue-cli-service build&quot;, //读取.env.production    &quot;test&quot;: &quot;vue-cli-service serve --mode=test&quot; //读取.env.test  &#125;&#125;\n\n本质node//package.json&#123;  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;cross-env NODE_ENV=development node test.js&quot; //cross-env解决不同系统的兼容性  &#125;&#125;\n\n新建.env 文件\n//.envBASE_URL = 127.0.0.1\n\n//main.jsrequire(&quot;dotenv&quot;).config(); //dotenv库用于从.env文件中读取配置console.log(process.env.NODE_ENV); //developmentconsole.log(process.env.BASE_URL); //127.0.0.1\n\n纯粹的 webpack 打包通过 definePlugins 定义到全局环境\nproject/|-- dist/|-- node_modules/|-- .env|-- app.js|-- package.json|-- webpack.config.js\n\n//package.json&#123;    ...    &quot;scripts&quot;: &#123;        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;    &#125;&#125;//webpack.config.jsmodule.exports = &#123;    mode: process.env.NODE_ENV, //打包方式，是否压缩文件    entry: &quot;./app.js&quot;,    output: &#123;        filename: &#x27;./bundle.js&#x27;    &#125;&#125;\n\n//app.jsconsole.log(process.env);\n\n在这里直接执行npm run build,编译后的文件为：\n//bundle.jsconsole.log(process.env); //这个代码拿到浏览器中是无法运行的,因为process是node的全局变量\n\n那么如何让 process.env 直接编译为变量的呢？\n1.引入 definePlugin\n//webpack.configlet webpack = require(&#x27;webpack&#x27;);require(&#x27;dotenv&#x27;).config();let obj = &#123;&#125;;Object.keys(process.env).forEach((key) =&gt;&#123;    if (key.indexOf(&#x27;VUE_APP&#x27;) !== -1) &#123;        const ipReg = /\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;/;  //如果直接传入127.0.0.1格式的文本会报错        if (ipReg.test(process.env[key])) &#123;            process.env[key] = `&quot;$&#123;process.env[key]&#125;&quot;`        &#125;        obj[key] = process.env[key]    &#125;&#125;)module.exports = &#123;    .... ,    plugins: [        new webpack.DefinePlugin(&#123;            &quot;process.env&quot; : obj,        &#125;)    ]&#125;\n\n执行npm run build生成 bundle.js 文件\n//.envVUE_APP_BASE_URL = &quot;127.0.0.1&quot;;//dist/bundle.jsconsole.log(&#123; VUE_APP_BASE_URL: &quot;127.0.0.1&quot; &#125;), console.log(1111);\n\n这样，我们就成功将环境变量传入 process.env 了\n","tags":["工程化"]},{"title":"文件上传","url":"/blog/2024/04/11/file-operation/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"方案：\n二进制 blob 搭载 formdata 传输\nbase64 传输\n\n相关对象file：通过 input 标签读过来的文件对象, 可以用于限制文件大小与类型等\n&lt;input type=&quot;file&quot; @change=&quot;handleChange&quot; /&gt;\n\n&lt;script setup&gt;const handleChange = (e) =&gt; &#123;  // 底层通过 new File进行转换为file对象  const file = e.target.files[0]  // 单文件上传就取0  if (file.size &gt; 10 * 1024 * 1024) &#123;    alert(&#x27;文件不得大于10M&#x27;)    return  &#125;  // 限制类型 、判空等等  ...&#125;&lt;/script&gt;\n\nblob：不可变的二进制内容\nconst sliceBlob = new Blob([file]).slice(0, 500); // Blob &#123;size: 500, type: &#x27;&#x27;&#125;\n\nfileReader ：多用于把文件读取为某种形式，比如 base 64 , 文本等\n&lt;img  : src=&quot;/blogimgUrl&quot;  style=&quot;width: 50px&quot; &gt;\n\nimport &#123; ref &#125; from &#x27;vue&#x27;const imgUrl = ref(&#x27;&#x27;)const handleChange = (e) =&gt; &#123;  ...  const fr = new FileReader()  fr.readAsDataURL(file) // 转为base64  fr.onload = function () &#123; // 因为fr.readAsDataURL是异步的    console.log(typeof fr.result) // string    imgUrl.value = fr.result  // 就可以在页面实现上传缩略图了  &#125;  // 更多操作如转文本：readAsText等&#125;\n\nformData ：用于和后端传输的对象\nconst handleChange = (e) =&gt; &#123;  const file = e.target.files[0]  ...  const formData = new FormData()  formData.append(&#x27;file&#x27;, file)  // File 是 Blob的子类， 所以可以直接将file放入  axios.post(&#x27;/404&#x27;, formData)&#125;\n\n类型转化关系：\n多文件上传相当于一个单文件上传的循环。\nconst fileList = ref(&quot;&quot;); // 文件暂存const handleChange = (e) =&gt; &#123;  if (e.target.files.length &gt; 1) &#123;    fileList.value = fileList.value.concat(e.target.files);  &#125; else &#123;    fileList.value.push(e.target.files[0]);  &#125;&#125;;// 点击上传const submit = () =&gt; &#123;  const formData = new FormData();  fileList.value.forEach((item, index) =&gt; &#123;    formData.append(&quot;file&quot; + index, item);  &#125;);  // formData.append(&#x27;file&#x27;, null)  axios.post(&quot;/404&quot;, formData);&#125;;\n\n切片上传let fileData = &#123;&#125;const handleChange = (e) =&gt; &#123;  // console.log(e.target.files[0])  ...  fileData = e.target.files[0]&#125;const submit = async () =&gt; &#123;  let fileSize = fileData.size  let sliceSize = 2 * 1024 * 1024  let current = 0  while (current &lt; fileSize) &#123;    const formData = new FormData()    formData.append(&#x27;filename&#x27;, fileData.slice(current, current + sliceSize))    await axios.post(&#x27;http://localhost:5173/api/upload&#x27;)    current += sliceSize  &#125;&#125;\n","tags":["vue3"]},{"title":"文件预览与解析","url":"/blog/2024/04/15/file-operation/excel%E4%B8%8Eword%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%A2%84%E8%A7%88/","content":"\n前置知识： 文件上传详解\n\n通用文件解析转化流程\n获取文件内容拿到文件内容后，就可以对其进行预览等操作。\n安装xlsx。\nnpm install xlsx\n\n本地选择文件&lt;template&gt;  &lt;input type=&quot;file&quot; @change=&quot;handleChange&quot; /&gt;&lt;/template&gt;\n\nimport &#123; read, utils &#125; from &quot;xlsx&quot;;// 选择文件后触发const handleChange = (e) =&gt; &#123;  const file = e.target.files[0];  // arrayBuffer: Blob接口自带的方法， 返回一个 Promise  file.arrayBuffer().then((data) =&gt; &#123;    const workSheet = read(data); // 读取为book对象    const sheet = workSheet.Sheets[&quot;话术推荐&quot;];    // 获取文件内容    const sheetJson = utils.sheet_to_json(sheet); // generate an array of JS objects    const sheetHtml = utils.sheet_to_html(sheet); // generates HTML code  &#125;);&#125;;\n\n接口请求const loadExcel = () =&gt; &#123;  axios.get(&quot;http://localhost:5000/download/excel&quot;).then((res) =&gt; &#123;    res.data.arrayBuffer().then((data) =&gt; &#123;      // 后续跟本地选择文件一样    &#125;);  &#125;);&#125;;\n\n生成 Excel 文件const tableRef = ref(null); // 获取table dom ，仅限于原生table元素const generateExcel = () =&gt; &#123;  // json对象转excel  const worksheet = utils.json_to_sheet(data); // 生成sheet  const workbook = utils.book_new(); // 生成book对象  utils.book_append_sheet(workbook, worksheet, &quot;sheet1&quot;);  writeFile(workbook, &quot;test1.xlsx&quot;);  // table dom 转excel  console.log(&quot;tableRef.value&quot;, tableRef.value);  const worksheet2 = utils.table_to_sheet(tableRef.value);  const workbook2 = utils.book_new();  utils.book_append_sheet(workbook2, worksheet2, &quot;sheet1&quot;);  writeFile(workbook2, &quot;test2.xlsx&quot;);&#125;;\n\nVue 预览实践通过xlsx拿到 excel 的数据后，可以拿到页面上进行预览等操作，但是生成的 html 没有样式，如何改善？请看vue-office/excel\ngithub 官网： https://github.com/501351981/vue-office\nreact 预览实践安装： react-file-viewer\nnpm 地址： https://www.npmjs.com/package/react-file-viewer\nWord通用文件解析安装docxtemplater\n预览关于 word 的预览与 excel 很类似，比如 vue 中使用vue-office/word， react 仍然使用react-file-viewer, 更多详情参考官网\n","tags":["vue3"]},{"title":"文件下载","url":"/blog/2024/04/13/file-operation/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","content":"\n前置知识： 文件上传\n\n利用 a 标签的 download 属性相关概念\ncreateObjectURL 把 blob 对象的内存地址，以 url 形式给出\n\nmsSaveblob兼容性考虑，IE 不支持 a 标签下载\n\na标签的download属性表面该 a 标签的行为是下载，并说明文件名\n\n\n流程按 blob 格式请求接口返回二进制文件：\n\n有 msSaveBlob —&gt; 用msSaveBlob下载\n无 msSaveBlob ：createObjectURL 创建文件本地 url —&gt; 创建 a 标签 —&gt; 创建 url 给到 a 标签的 href —&gt; 设置 download —&gt; 模拟点击 a 标签 —&gt; 下载完成\n\n​\n实现export function downloadFile(data, filename) &#123;  // 以excel为例  const mimeType =    &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;;  // 兼容IE  if (window.navigator.msSaveBlob) &#123;    window.navigator.msSaveBlob(res, &#123; type: mimeType &#125;);  &#125; else &#123;    const blob = new Blob([res], &#123; type: mimeType &#125;); // 拿到的数据是bob格式这一行可以不要    const url = URL.createObjectURL(blob);    let link = document.createElement(&quot;a&quot;);    link.href = url;    link.download = filename;    link.style.display = &quot;none&quot;;    link.click();    URL.revokeObjectURL(url);  &#125;&#125;\n\nfile-saverFileSaver.js is the solution to saving files on the client-side\nnpm i file-saver\n\nimport &#123; saveAs &#125; from &quot;file-saver&quot;;saveAs(blobData, filename);\n\n测试 democonst Koa = require(&#x27;koa&#x27;)const Router = require(&#x27;koa-router&#x27;)const ExcelJS = require(&#x27;exceljs&#x27;)const fs = require(&#x27;fs&#x27;)const router = new Router(&#123; prefix: &#x27;/api&#x27; &#125;)router.get(&#x27;/downloadExcel&#x27;, async (ctx, next) =&gt; &#123;  // 生成Excel文件  const workbook = new ExcelJS.Workbook()  const worksheet = workbook.addWorksheet(&#x27;Sheet 1&#x27;)  worksheet.columns = [    &#123; header: &#x27;Name&#x27;, key: &#x27;name&#x27;, width: 20 &#125;,    &#123; header: &#x27;Age&#x27;, key: &#x27;age&#x27;, width: 10 &#125;  ]  worksheet.addRow(&#123; name: &#x27;John Doe&#x27;, age: 30 &#125;)  // 保存Excel文件为二进制流  const buffer = await workbook.xlsx.writeBuffer()  // 发送响应  ctx.set(&#x27;Content-disposition&#x27;, &#x27;attachment; filename=example.xlsx&#x27;)  ctx.set(&#x27;Content-Type&#x27;, &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;)  ctx.body = buffer&#125;)const app = new Koa()app.use(router.routes())app.listen(5000, () =&gt; &#123;  console.log(&#x27;server is running on http://localhost:5000&#x27;)&#125;)\n","tags":["vue3"]},{"title":"移动端适配","url":"/blog/2024/04/28/mobile/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","content":"核心思想\n基本原则： 布局更多地使用 flex， 然后尺寸使用 rem，vw，vh 为单位\n如果是根据不同的屏幕需要有不同的布局了，一般通过检测屏幕尺寸\n\n如何监听屏幕？\n尺寸remhtml 标签的font-size属性大小就为 1rem，比如 font-size 设置为 16px, 1rem 就是 16px。\nhtml 字体大小 &#x3D; （js 获取到的设备宽度&#x2F;设计图的宽度) * 设计图宽度下的 1rem。\n设置 html 的 fontsize 并监听窗口变化\n&lt;script lang=&quot;ts&quot; setup&gt;import &#123; onMounted, onUnmounted &#125; from &#x27;vue&#x27;onMounted(() =&gt; &#123;  setHtmlFontsize()  window.addEventListener(&#x27;resize&#x27;, setHtmlFontsize) // 监听窗口大小变化&#125;)onUnmounted(() =&gt; &#123;  window.removeEventListener(&#x27;resize&#x27;, setHtmlFontsize)&#125;)const setHtmlFontsize = () =&gt; &#123;  let clientWidth = Math.min(window.innerWidth, 750) // 获取浏览器窗口的宽度  let fontsize = (clientWidth / 750) * 100  document.documentElement.style.fontSize = fontsize + &#x27;px&#x27;&#125;&lt;/script&gt;\n\n这个时候我们就可以对元素进行 rem 设置:\n.box &#123;  width: 1rem; /* 1rem 这里就为100px */  height: 1rem;  background-color: red;&#125;\n\n但是每次我们设置宽度的时候都需要手动地计算px与rem的换算比例；\n我们可以使用postcss-pxtorem来帮我们自动计算：\n\n安装\nnpm install postcss postcss-pxtorem --save-dev\n\n配置，此处以 vite 创建的项目为例\n//vite.config.ts...import postcssPxtorem from &#x27;postcss-pxtorem&#x27;// https://vitejs.dev/config/export default defineConfig(&#123;  ...,  css: &#123;    postcss: &#123;      plugins: [        postcssPxtorem(&#123;          rootValue: 100,          unitPrecision: 3, // 运行rem精确的小数位          propList: [&#x27;*&#x27;], // 需要转换的属性, 这里的*代表所有          selectorBlackList: [&#x27;ignore&#x27;], // 要忽略的选择器，[&#x27;ignore&#x27;] 将匹配 .ignore-class          replace: true, // 是否转换后直接更换属性值          mediaQuery: false, // 允许在媒体查询中转换px          minPixelValue: 0, // 要替换的最小像素值          exclude: /node_modules/i        &#125;)      ]    &#125;  &#125;,  ...&#125;)\n\n最终代码：\n.box &#123;  width: 100pz;  height: 100pz;  background-color: red;&#125;\n\n我们在浏览器也可以看到 px 是被转换为 rem 了。\n\n\nvw、vhvw 是视口宽度， 1vw 就是 1%的宽度，vh 同理。\n一般设置盒子都是使用 vw， 而 vh 一般用来做全屏设计。\n\n安装npm install postcss-px-to-viewport --save-dev\n\n配置\npostcssPxToViewport(&#123;  unitToConvert: &quot;px&quot;,  viewportWidth: 750,  unitPrecision: 3,  propList: [&quot;*&quot;],  viewportUnit: &quot;vw&quot;,  fontViewportUnit: &quot;vw&quot;,  selectorBlackList: [&quot;ignore-&quot;],  minPixelValue: 1,  mediaQuery: false,  replace: true,  exclude: [/node_modules/i],&#125;);\n\n方案对比：rem vs vw\n\nrem 相对于 vw 的灵活度更高， 如果移动端项目可能涉及到 web 端的浏览，rem 可以做到 vw 做不到的事情；\nrem 如果不监听 resize 事件去修改 fontSize 是无法做到动态改变元素大小的，如果变化无法触发 resize 可使用 vw\n\n百分比：需要根据父元素的缩放调整元素\n注意事项：\n图片一般定宽不定高，防止图片变形； 如果屏幕跨度过大，可设置最大宽度；\n在大屏可视化项目中， F11 切为全屏，不会引起宽度变化， 可能会导致元素位置错乱。 所以这种需求的项目，有的高度可以用 vh 来做。\n\n","tags":["移动端"]},{"title":"Node-实现一个简易的脚手架","url":"/blog/2024/06/24/node/Node-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/","content":"实现一个简易的脚手架：创建一个全局命令package.json 配置：\n&#123;\t...,\t&quot;scripts&quot;: &#123;    \t...,    \t&quot;cli&quot;: &quot;node index.js&quot;  // 在项目下可以实现与bin命令一样的效果  \t&#125;,  \t&quot;bin&quot;: &#123;    \t&quot;my-cli&quot;: &quot;index.js&quot;  // bin命令任意文件夹可调用  \t&#125;,&#125;\n\n运行的脚本文件需要在顶部配置：以 node 环境去执行该文件\n#!/usr/bin/env nodeconsole.log(&quot;hi cli&quot;);\n\n执行npm link将当前包链接到全局 npm 模块缓存中, 然后就可以在任意路径下执行my-cli:\nPS C:\\Users\\14596\\Desktop&gt; my-clihi cli\n\n为工具添加交互使用inquirer库：\nimport inquirer from &quot;inquire&quot;;inquirer  .prompt([    &#123;      type: &quot;input&quot;,      name: &quot;ProjecName&quot;,      message: &quot;请输入项目名&quot;,    &#125;,    &#123;      type: &quot;list&quot;,      name: &quot;ProjecType&quot;,      message: &quot;请选择Vue/React&quot;,      choices: [&quot;Vue&quot;, &quot;React&quot;],    &#125;,    &#123;      type: &quot;checkbox&quot;,      name: &quot;projectFeature&quot;,      message: &quot;请选择要添加的功能&quot;,      choices: [&quot;router&quot;, &quot;redux&quot;, &quot;axios&quot;],    &#125;,    &#123;      type: &quot;confirm&quot;,      name: &quot;projectSave&quot;,      message: &quot;是否要保存项目配置&quot;,    &#125;,  ])  .then((res) =&gt; &#123;    console.log(res);  &#125;);/*&#123;  ProjecName: &#x27;demo&#x27;,  ProjecType: &#x27;Vue&#x27;,  projectFeature: [ &#x27;router&#x27;, &#x27;redux&#x27; ],  projectSave: false&#125;*/\n\n\n注意：在 node14 以下是完全无法使用 ESM 语法的，在 14 版本及以上如果要使用 ESM 语法需要在package.json中配置&quot;type&quot;: &quot;module”, 否则默认支持 commonJS 语法\n\n拉取项目模板\n在与用户交互的时候，我们对用户所选的配置应该返回对应的模板, 但模板的处理是一项复杂的工程，仍需不断学习。这里主要的实现逻辑就为选着哪种框架，就直接拉取其代码\n\n使用download-git-repo库\n...    .then((res) =&gt; &#123;        let _target = &quot;Vuejs/vue&quot;;        let outputDir = path.resolve(process.cwd(), res.ProjecName);  // 将项目保存在进程执行处        if (res.ProjecType === &quot;React&quot;) &#123;            _target = &quot;facebook/react&quot;;        &#125;        fs.mkdirSync(outputDir);  // 下载前需要创建好对应的文件夹        downloadGit(&quot;github:&quot; + _target, outputDir, &#123;&#125;, (err, res) =&gt; &#123;            if (err) &#123;                throw err;            &#125;            console.log(&quot;download sucessfully&quot;);        &#125;);    &#125;);\n\n到这里，一个简单完整的脚手架创建项目流程就已经实现了\n除此之外， 我们还可以为我们的cli添加一些命令功能\n命令行参数添加使用commander库\nimport &#123; Command &#125; from &quot;commander&quot;;let program = new Command();program.version(&quot;1.2.3&quot;, &quot;-V, --version&quot;, &quot;output the version number&quot;); // 添加版本号的特有方法// 命令式program  .command(&quot;create &lt;name&gt;&quot;) //尖括号表示必填， 方括号表示选填  .description(&quot; create a new project powered by vue-cli-service&quot;)  .option(&quot;-s, --separator &lt;char&gt;&quot;, &quot;separator character&quot;, &quot;,&quot;) // 只是传参给action的第二个参数  .action((str, options) =&gt; &#123;    console.log(str, options);    /*      str: command 命令拿到的参数      options: &#123;separator : &#x27;,&#x27;&#125;    */  &#125;);program.parse(process.argv); // -h, --help 会被自动注入\n\n扩展为 cli 的交互字体添加一些样式当前创建模板的时候，字体全是白色\n使用chalk库\nimport chalk from &#x27;chalk&#x27;...console.log(chalk.green(&quot;download sucessfully&quot;));\n\n下载反馈现在从远程仓库拉取模板的时候，是一个光标在闪，不太友好。\n使用ora库\nimport ora from &#x27;ora&#x27;;....then(()=&gt;&#123;    let spinner = ora(&#x27;下载中&#x27;).start();    ...    //下载完成    spinner.stop()&#125;)\n\n日常操作工具把一些经常复用的内容通过工具直接输出出来\n命令行操作import child_process from &quot;child_process&quot;;\n\n推荐用shelljs\n","tags":["node"]},{"title":"一文搞懂import到底在引入什么","url":"/blog/2024/06/11/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82import%E5%88%B0%E5%BA%95%E5%9C%A8%E5%BC%95%E5%85%A5%E4%BB%80%E4%B9%88/","content":"\n通过这篇文章，你可以学会：\n\n搞懂 package.json 的几个重要字段\n明白 import 引入模块时的机制，引入一个模块到底引入的是哪个文件\n\n\n文件夹查找机制\n如果加了“.&#x2F;“, “&#x2F;“这样的具体路径， 那么就直接按照路径找\n如果只写了模块名，就从node_modules中查找对应的文件夹\n\n导入一个库\n执行import ... from &#39;...&#39;\n去查找该库是否有package.json文件，并且有对应的控制字段\n如果有就去根据main等字段综合决定；没有就引入index.js\n\npackage.json核心字段\nmain： 一般常用，浏览器和 node 环境均生效\nmodule : ESM 规范入口，node 无效\nbrowser： 浏览器环境下的入口\nexports ： 可以覆盖前面属性，定义 import 和 require 分别引入什么，node14.13 后支持\n\nmain &amp;&amp; module &amp;&amp; browser 的应用在浏览器环境下使用 import 引入的字段读取优先级：browser &gt; module &gt; main ,都没有等于package.json（读取 index.js)\n在 node 环境下使用 require 引入时读取main ， 其他无效, 如果没有 main 等同于没有package.json\nexports 的应用使用这种方式配置引入文件时，在组件中引入的库（文件夹）需要放在 node_modules 中才能生效\n&#123;  /*  存在exports都会被覆盖  &quot;main&quot;: &quot;index.js&quot;,  &quot;browser&quot;: &quot;test.browser.js&quot;,  &quot;module&quot;: &quot;test.module.js&quot;,  */   ...,  &quot;exports&quot;: &#123;    &quot;.&quot;: &#123;      &quot;import&quot;: &quot;./test.exports.js&quot;    &#125;,\t// 如果有非默认路径，被引入的文件夹必须放入node_modules，否则报错    &quot;./static&quot;: &#123;      &quot;import&quot;: &quot;./test.static.js&quot;    &#125;  &#125;,&#125;\n\n文件引入：\nimport importTest from &quot;importTest&quot;;import importTestStatic from &quot;importTest/static&quot;;\n","tags":["工程化"]},{"title":"node基础","url":"/blog/2024/06/11/node/node-%E5%9F%BA%E7%A1%80/","content":"\n可以说，node 改变了前端的开发方式：\n\n为前端提供开发工具（vue-cli, webpack 等）\n提供线上环境模拟\n提供中间层服务器渲染（ssr，高流量项目）\n做后端服务（极少）\n\n\n常用工具模块核心操作\n\n读写文件\n开启服务\n\npath-路径处理工具\ntips: node 里面的全局对象是 global，不存在 window\n\nbasename &amp;&amp; dirname路径最后一部分 &amp;&amp; 目录名，除去文件名的路径\nconst a = &quot;./src/test/a.js&quot;;const path = require(&quot;path&quot;);// The &quot;path&quot; argument must be of type stringconsole.log(path.basename(a)); // a.jsconsole.log(path.dirname(a)); // ./src/test\n\nparse &amp;&amp; format解析路径为对象 &amp;&amp; 对象解析为路径\nconsole.log(path.parse(a)); // &#123; root: &#x27;&#x27;, dir: &#x27;./src/test&#x27;, base: &#x27;a.js&#x27;, ext: &#x27;.js&#x27;, name: &#x27;a&#x27; &#125;console.log(  path.format(&#123;    root: &quot;&quot;,    dir: &quot;./src/test&quot;,    base: &quot;a.js&quot;,    ext: &quot;.js&quot;,    name: &quot;a&quot;,  &#125;)); //./src/test\\a.js\n\nresolve(常用)拼接路径，常用于解析绝对路径\nconsole.log(path.resolve(__dirname, &quot;./static&quot;)); // C:\\Users\\14596\\Desktop\\node\\staticconsole.log(path.resolve(&quot;../&quot;, &quot;./static&quot;)); // C:\\Users\\14596\\Desktop\\static\n\njoin字符串拼接\nconsole.log(path.join(&quot;a&quot;, &quot;b&quot;)); // a\\b\n\nprocess-进程\n程序执行的进程信息，全局变量，无需手动引入\n\nargv &amp;&amp; execArgv启动 node 时的命令行参数 &amp;&amp; node 命令后的直接参数\nconsole.log(process.argv);/*PS C:\\Users\\14596\\Desktop\\node&gt; node .\\test.js -a -b[  &#x27;C:\\\\Program Files\\\\nodejs\\\\node.exe&#x27;,  &#x27;C:\\\\Users\\\\14596\\\\Desktop\\\\node\\\\test.js&#x27;,  &#x27;-a&#x27;,  &#x27;-b&#x27;]*/console.log(process.execArgv); // 拿到的是紧接着node所接的参数/*PS C:\\Users\\14596\\Desktop\\node&gt; node  --abort-on-uncaught-exception .\\test.js[ &#x27;--abort-on-uncaught-exception&#x27; ]*/\n\nenv用户环境信息，在日常开发中最大的作用是接收 node 环境信息\nprocess.env.NODE_ENV = &quot;production&quot;;console.log(process.env.NODE_ENV); // production\n\ncwd()获取当前进程的工作目录\nconsole.log(process.cwd());/*PS C:\\Users\\14596\\Desktop&gt; node .\\node\\test.jsC:\\Users\\14596\\Desktop*/\n\n\n与__dirname 的区别？\ncwd()是执行命令行所在目录，__dirname 是被执行的文件所在目录\n\nstdout &amp;&amp; stdin屏幕输入与输出，可实现用户交互\nprocess.stdout.write(&quot;please write your project-name:&quot;);process.stdin.on(&quot;data&quot;, (res) =&gt; &#123;  console.log(res.toString());&#125;);\n\n但是现在的命令行会一直在交互进程中….\nexit() &amp;&amp; 监听退出进程 &amp;&amp; 监听（退出）事件\nprocess.stdin.on(&quot;data&quot;, (res) =&gt; &#123;  ...  process.exit();&#125;);process.on(&#x27;exit&#x27;, () =&gt; &#123;    console.log(&#x27;创建成功&#x27;);&#125;)\n\nmemoryUsage()内存使用情况\nconsole.log(process.memoryUsage());/** &#123;  rss: 19128320,  heapTotal: 4866048,  heapUsed: 3967912,  external: 221041,  arrayBuffers: 11146&#125;*/\n\n进程功能是极其复杂的，比如多进程，进程管理等，我们日常的中后台项目开发熟悉以上知识即可。\nutil 工具函数const util = require(&quot;util&quot;);\n\npromisify把异步回调包装为 promise 形式\nconst readFile = util.promisify(fs.readFile);readFile(&quot;./text.txt&quot;).then((res) =&gt; &#123;  console.log(res.toString());&#125;);\n\ncallbackify将一个返回值为 promise 的函数改为回调\nfunction fn() &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(100);    &#125;);  &#125;);&#125;const callback = util.callbackify(fn);callback((error, res) =&gt; &#123;  console.log(res); // 100&#125;);\n\n\n规律： node 中所有的异步操作都是通过回调获取结果的， 几乎所有的回调函数第一个参数都是错误信息， 后面的才是结果\n\n文件操作const fs = require(&quot;fs&quot;);\n\n\ntips:\n\n文件读取方法全部都是异步操作 ， 那么就会涉及到回调，promise\n文件操作的异步形式都会有一个回调，在最后一个参数\n所有方法都有同步版本，在方法后面加上sync\n\n\n文件基本操作读取-readFile// 异步fs.readFile(&quot;./test1.txt&quot;, (err, data) =&gt; &#123;  console.log(data.toString());&#125;);// 同步const data = fs.readFileSync(&quot;./test1.txt&quot;);console.log(data.toString());\n\n写入-writeFile写入路径必须存在\n// 异步fs.writeFile(&quot;./test.txt&quot;, &quot;hello writeFile&quot;, (err, res) =&gt; &#123;&#125;);// 同步const res = fs.writeFileSync(&quot;./test2.txt&quot;, &quot;hello sync&quot;);\n\n后续都不再书写同步方法，原理与读写与写入一致\n删除-unlinkfs.unlink(&quot;./test1.txt&quot;, () =&gt; &#123;&#125;); // 回调必传\n\n插入-appendFilefs.appendFile(&quot;./test.txt&quot;, &quot;append&quot;, () =&gt; &#123;&#125;);\n\n移动（重命名）- rename// 重命名fs.rename(&quot;./test.txt&quot;, &quot;./test2.txt&quot;, () =&gt; &#123;&#125;);// 移动fs.rename(&quot;./test2.txt&quot;, &quot;./src/test2.txt&quot;, () =&gt; &#123;&#125;);\n\n实际上就是删除原有的并在指定位置创建新的文件。\n拷贝- copyFilefs.copyFile(&quot;./src/a.js&quot;, &quot;./src/b.js&quot;, () =&gt; &#123;&#125;);\n\n\n扩展： 如果想对文件内容进行一定的修改再拷贝可以读取文件后，经过处理再去写入\n\n文件夹的操作读取-readdirfs.readdir(&quot;./src&quot;, (err, data) =&gt; &#123;  console.log(data);&#125;)[  // 打印结果  (&quot;a.js&quot;, &quot;b.js&quot;, &quot;test2.txt&quot;)];\n\n创建-mkdirfs.mkdir(&quot;./dist&quot;, () =&gt; &#123;&#125;);\n\n删除-rmdir注意：被删除的必须是空文件夹\nfs.rmdir(&quot;./empty&quot;, () =&gt; &#123;&#125;);\n\n如果想要删除所有文件该如何做？\nfunction deleteAllFile(dirPath) &#123;  if (fs.existsSync(dirPath)) &#123;    let content = fs.readdirSync(dirPath);    content.forEach((item) =&gt; &#123;      let fullPath = path.join(dirPath, item);      let _stat = fs.statSync(fullPath);      // 如果是目录      if (_stat.isDirectory()) &#123;        deleteDirectory(fullPath);      &#125; else &#123;        // 是文件就删除文件        fs.unlink(fullPath, () =&gt; &#123;&#125;);      &#125;    &#125;);    // fs.rmdirSync(dirPath); // 文件夹一起删除  &#125; else &#123;    console.error(&quot;路径不存在&quot;);  &#125;&#125;\n\n拷贝 &amp;&amp; 移动这两个没有直接的 api，必须遍历\nfunction copyDir(source, target) &#123;  if (!fs.existsSync(source)) &#123;    console.error(&quot;源文件夹不存在&quot;);    return;  &#125;  // 目标文件夹不存在  if (!fs.existsSync(target)) &#123;    fs.mkdirSync(target);  &#125;  let sourceContent = fs.readdirSync(source);  sourceContent.forEach((item) =&gt; &#123;    let sourcePath = path.join(source, item);    let targetPath = path.join(target, item);    let source_stat = fs.statSync(sourcePath);    if (source_stat.isDirectory()) &#123;      copyDir(sourcePath);    &#125; else &#123;      fs.copyFileSync(sourcePath, targetPath);    &#125;  &#125;);&#125;\n\n上面对文件夹的删除，拷贝，移动等代码主要是为了帮助理解其中的思路，一般来说推荐使用第三方库。\n一些好用的第三方库fs-extra\nfs-extra adds file system methods that aren’t included in the native fs module and adds promise support to the fs methods\n\n// 复制文件夹fse.copySync(&quot;./src&quot;, &quot;./target&quot;);// 移动文件夹fse.moveSync(&quot;./dist&quot;, &quot;./target&quot;); // dist文件夹的内容移动到指定文件夹// 清空文件夹fse.emptyDirSync(&quot;./target&quot;);// 删除文件夹fse.removeSync(&quot;./target&quot;);\n\ncompressingcompressing.tgz.compressDir(&quot;./src&quot;, &quot;./src.tgz&quot;);compressing.tgz.uncompress(&quot;./src.tgz&quot;, &quot;./&quot;);\n\nnpm 官网： https://www.npmjs.com/package/compressing\nbuff 与流\n我们在实际开发中基本不会涉及到 Buffer 与 Stream 的操作，这一节主要是理解一些服务的底层运作原理，比如 http 服务\n\nbufferbuffer可以理解为一个固定长度的“字符串”数组，存在于 v8 内存，存储文件二进制内容的缓冲区\nfse.readFile(&quot;./test.js&quot;, (err, res) =&gt; &#123;  // 这里的data 就是buffer  // 后续处理  let data = res.toString();  // ...&#125;);\n\nBuffer 类的常用操作alloc：初始化的新 Buffer\n// If `fill` is `undefined`, the`Buffer` will be zero-filledconst buf = Buffer.alloc(5);console.log(buf); //  &lt;Buffer 00 00 00 00 00&gt;// If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.const buf = Buffer.alloc(5, &quot;123&quot;);console.log(buf.toString()); // Prints: 12312\n\nfrom： 新建 buffer。从现有的数据结构创建或复制一个 Buffer\nconst buf = Buffer.from(JSON.stringify(&#123; a: 1 &#125;));\n\nisBuffer：判断是否为Buffer\n// Returns `true` if `obj` is a `Buffer`, `false` otherwise.Buffer.isBuffer(buf);\n\nBuffer 对象常用操作toString() ：Decodes buf to a string\nlength：The length of the array\n流（Stream）可理解为一个管道， 作为Buffer的传输通道\n使用场景： 大文件传输等\nlet readStream = fs.createReadStream(&quot;./test.pdf&quot;);let writeStream = fs.createWriteStream(&quot;./test2.pdf&quot;);readStream.on(&quot;data&quot;, (chunk) =&gt; &#123;  writeStream.write(chunk);&#125;);readStream.on(&quot;close&quot;, () =&gt; &#123;  console.log(&quot;读取完毕&quot;);&#125;);writeStream.on(&quot;finish&quot;, () =&gt; &#123;  console.log(&quot;写入完成&quot;);&#125;);\n\n如果不作其他处理，可以简写为：\nreadStream.pipe(writeStream);\n\n开启 http 等各种服务\ntitle: node 基础（4）- 开启 http 等各种服务date: 2024-6-22tags:\n\nnode\n\n\n网络协议的共同的：\n\n都会有客户端和服务端\n大多数操作都是流的形式\n\nhttp服务端\n开启一个服务，服务的本质就是收到请求，返回内容\nconst http = require(&quot;http&quot;);const server = http.createServer();server.on(&quot;request&quot;, (req, res) =&gt; &#123;  res.end(&quot;hello word&quot;); // res的本质就是写入流&#125;);server.listen(3000, () =&gt; &#123;  console.log(&quot;启动成功&quot;);&#125;);\n\n根据网址显示不同页面\n\n借助url模块对拿到的 url 进行处理，分离pathName和query\nconst url = require(&quot;url&quot;);...const &#123;pathname, query&#125; = url.parse(req.url);\n\n编写不同页面的逻辑\nif (pathname === &#x27;/page1&#x27;) &#123;    res.write(&#x27;hello&#x27;) // 前面提到res实际上是写入流, 所以可以往里面写入数据    res.end(&#x27;page1&#x27;)  // end后的代码不再执行&#125;...\n\n如果返回一个html文件\n...if (pathname === &quot;/index.html&quot;) &#123;    let readStream = fs.createReadStream(&#x27;./index.html&#x27;); // 将html读作流    readStream.on(&quot;data&quot;, (chunk) =&gt; &#123;   \t res.write(chunk);    &#125;);    readStream.on(&quot;close&quot;, () =&gt; &#123;    \tres.end();    &#125;);&#125;\n\n如果在 html 中引入了静态资源\n...// 当html引入了静态资源的时候，html加载完成后就会发起请求静态资源, 也需要一个接口if (pathname === &quot;/index.css&quot;) &#123;\tlet indexCss = fs.createReadStream(&quot;./index.css&quot;);    indexCss.on(&quot;data&quot;, (chunk) =&gt; &#123;    \tres.write(chunk);    &#125;);\tindexCss.on(&quot;end&quot;, () =&gt; &#123;\t\tres.end();\t&#125;);&#125;\n\n\n编写 get 接口\nif (method === &quot;GET&quot;) &#123;  if (pathname === &quot;/list&quot;) &#123;    res.end(      JSON.stringify(&#123;        data: [1, 2, 3],      &#125;)    );  &#125; else &#123;    res.statusCode = 404; // 设置响应状态码    res.setHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;); // 设置响应头    res.end(      JSON.stringify(&#123;        message: &quot;接口不存在&quot;,      &#125;)    );  &#125;&#125;\n\n编写 post 请求，本质上是获取可读流的内容（req)\n\n\n客户端\nGET 方式请求\nhttp.get(&quot;http://localhost:3000/list&quot;, (res) =&gt; &#123;  // res : 可读流  let data = &quot;&quot;;  res.on(&quot;data&quot;, (chunk) =&gt; &#123;    data += chunk;  &#125;);  res.on(&quot;end&quot;, () =&gt; &#123;    console.log(JSON.parse(data));  &#125;);&#125;);\n\nPost 方式请求\nconst request = http.request(  &#123;    hostname: &quot;localhost&quot;,    port: 3000,    path: &quot;/updateName&quot;,    method: &quot;POST&quot;,  &#125;,  (res) =&gt; &#123;    let data = &quot;&quot;;    res.on(&quot;data&quot;, (chunk) =&gt; &#123;      data += chunk;    &#125;);    res.on(&quot;end&quot;, () =&gt; &#123;      console.log(data);    &#125;);  &#125;);// The &quot;chunk&quot; argument must be of type string or an instance of Buffer or Uint8Arrayrequest.write(  JSON.stringify(&#123;    id: 1,  &#125;));request.end();// 设置请求头 ： request.setHeader\n\nhttps安装并创建证书（非正式）, 参考：https://www.npmjs.com/package/mkcert#create-a-certificate-authority\n创建https服务：\n// httpsServer.jsconst https = require(&quot;https&quot;);const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const certOption = &#123;  key: fs.readFileSync(path.resolve(__dirname, &quot;./cert.key&quot;)),  cert: fs.readFileSync(path.resolve(__dirname, &quot;./cert.crt&quot;)),&#125;;const app = https.createServer(certOption);app.on(&quot;request&quot;, (req, res) =&gt; &#123;  res.end(&quot;123&quot;);&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;启动https服务成功&quot;);&#125;);\n\n其他与http服务大同小异\nwebsocket原生构建过于麻烦，这里推荐使用第三方库ws\n// wsServer.jsconst ws = require(&quot;ws&quot;);const webSocketServer = ws.WebSocketServer;const wss = new webSocketServer(&#123;  port: 8080,&#125;);wss.on(&quot;connection&quot;, (ws) =&gt; &#123;  ws.on(&quot;message&quot;, (res, err) =&gt; &#123;    console.log(res.toString());  &#125;);  ws.send(&quot;返回ws数据&quot;);&#125;);\n\n客户端（浏览器）交互：\n// wsClient.jsconst ws = new WebSocket(&quot;ws://localhost:8080&quot;);// 连接完成ws.onopen = function (event) &#123;  console.log(&quot;WebSocket is open now.&quot;);  ws.send(&quot;hi ws&quot;);&#125;;// 服务端那边有数据ws.onmessage = function (res) &#123;  console.log(&quot;从服务端来的数据&quot;, res);&#125;;\n\n客户端（node）交互：\nconst Websocket = require(&quot;ws&quot;);const ws = new Websocket(&quot;ws://localhost:8080&quot;);ws.onopen = function () &#123;  console.log(&quot;WebSocket is open now.&quot;);  ws.send(&quot;hi ws&quot;); // 连接是异步的，代码写在连接完成后&#125;;ws.onmessage = function (res) &#123;  console.log(&quot;从服务端来的数据&quot;, res);&#125;;\n","tags":["node"]},{"title":"Node-实现一个简易的脚手架","url":"/blog/2024/06/26/node/%E9%80%9A%E8%BF%87node%E7%BC%96%E5%86%99K8s%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/","content":"\n公司有时候做了需求出包没法走流水线， 只能自己手动打包到 k8s 的 pod 里面去打包， 太麻烦， 于是写了一个脚本每次一条命令就可以把自动拉去包到本地的脚本\n\n代码全部写在一个文件中，但这里分开解释;\n为了与远程机器创建 SSH 连接，安装ssh2, 并引入:\nimport &#123; Client &#125; from &quot;ssh2&quot;;const conn = new Client();\n\n配置:\nconst config = &#123;  serverIp: &quot;172.16.30.xx&quot;,  user: &quot;ops&quot;,  password: &quot;xx&quot;,  workDir:    &quot;/data/jenkins/workspace/k8s-envs/devops-30033586-uat-pal-180-pj860/opt&quot;,  namespace: &quot;devops-30033586-uat-pal-180-pj860&quot;,  kubeConfig: &quot;.kube_config.yaml&quot;, // 使用的 Kubernetes 配置文件的路径  localDir: &quot;/tmp/pal&quot;, // 宿主机打包位置  remoteFile: &quot;pal-portal.tar.gz&quot;, // 打包后的文件名&#125;;\n\nPromisefy在正式开始连接之前， 因为我们需要对回调函数进行Promisefy\nimport &#123; promisify &#125; from &quot;util&quot;;// 在这里来执行回调函数const execCommand = (conn, command) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    conn.exec(command, (err, stream) =&gt; &#123;      if (err) return reject(err);      let data = &quot;&quot;;      let errorData = &quot;&quot;;      stream        .on(&quot;close&quot;, (code, signal) =&gt; &#123;          if (code === 0) &#123;            resolve(data);          &#125; else &#123;            reject(new Error(errorData));          &#125;        &#125;)        .on(&quot;data&quot;, (chunk) =&gt; (data += chunk))        .stderr.on(&quot;data&quot;, (chunk) =&gt; (errorData += chunk));    &#125;);  &#125;);&#125;;\n\n注意： 每个conn.exec都是一个单独的进程， 比如你想要进入到/data/opt下的文件创建一个文件夹， 比如使用&amp;&amp; 连续执行 cd /data/opt &amp;&amp; mkdir dirDemo\n创建连接：conn  .on(&quot;ready&quot;, async () =&gt; &#123;    try &#123;      console.log(&quot;ssh连接成功&quot;);    &#125; catch (error) &#123;      console.log(&quot;error&quot;, error);    &#125; finally &#123;      conn.end();      console.log(&quot;连接已断开...&quot;);    &#125;  &#125;)  .connect(&#123;    host: config.serverIp,    port: 22,    username: config.user,    password: config.password,  &#125;);\n\n在 K8s 部署环境中有多个 pods， 而且是经常变化的，那么我们需要先获取所有 pods 的名字：\nconn  .on(&quot;ready&quot;, async () =&gt; &#123;      console.log(&quot;ssh连接成功&quot;);      const pods = await execCommand(        conn,        `cd $&#123;config.workDir&#125; &amp;&amp;        kubectl --kubeconfig=$&#123;config.kubeConfig&#125; -n=$&#123;config.namespace&#125; get pods -o=jsonpath=&#x27;&#123;.items[*].metadata.name&#125; &#x27;`      );      const podList = pods.trim().split(&quot; &quot;)  &#125;)  .connect(&#123;    ...  &#125;);\n\n\n命令解析：\n\n-o 等于 **&#96;–output， 指定了 kubectl 命令的输出格式\n&#123;.items[\\*].metadata.name&#125;选取 JSON 对象中名为items的键下所有的元素下的metadata对象中的name字段\n\n\n选择 pod拿到所有的 pods 了，用户需要进行选择，使用库inquirer：\nimport inquirer from &quot;inquirer&quot;;conn  .on(&quot;ready&quot;, async () =&gt; &#123;      ... \t  // 让用户选择容器      const answers = await inquirer.prompt([        &#123;          type: &quot;list&quot;,          name: &quot;podName&quot;,          message: &quot;请选择你要打包的模块&quot;,          choices: podList,        &#125;,      ]);      const selectedPod = answers.podName;      // 开始在容器打包并拉取到本地      await runCompile(selectedPod);  &#125;)  .connect(&#123;    ...  &#125;);\n\n编写上面代码中提到的runCompile：\n打包将选中的 pod 打包\nconst runCompile = async (podName) =&gt; &#123;  const commands = `    cd $&#123;config.workDir&#125; &amp;&amp;  kubectl --kubeconfig=$&#123;config.kubeConfig&#125; -n=$&#123;config.namespace&#125; exec $&#123;podName&#125; -- sh -c &quot;        cd ../ &amp;&amp;        tar -zcvf $&#123;config.remoteFile&#125; pal-portal &amp;&amp;        mv pal-portal.tar.gz pal-portal &amp;&amp;        &amp;&amp; exit      &quot; `;  await execCommand(conn, commands);  console.log(&quot;pod打包完成...&quot;);  ...&#125;;\n\n\n命令解析：\n\n&#96;&#96;– sh -c: 表示后续的参数不应该被解释为 kubectl exec&#96; 的选项， 而是作为要传递给容器的命令\n当在 kubectl exec 命令后不要添加 -it 参数时，它会启动一个交互式会话，这在自动化脚本中会导致挂起\n在 kubectl exec 中使用 sh -c 后面接的是在 k8s 中需要执行的命令\n\n\n将打好的包复制到宿主机中：\nconst runDeploy = async (podName) =&gt; &#123;  console.log(&quot;从容器复制到宿主机...&quot;);  await execCommand(    conn,    `cd $&#123;config.workDir&#125; &amp;&amp; kubectl --kubeconfig=$&#123;config.kubeConfig&#125; -n=$&#123;config.namespace&#125; cp $&#123;podName&#125;:$&#123;config.remoteFile&#125; $&#123;config.localDir&#125;/$&#123;config.remoteFile&#125;`  );  console.log(&quot;从容器复制到宿主机完成&quot;);&#125;;\n\n下载到本地通过实例conn的sftp方法初始化一个 SFTF\nconst runDeploy = async (podName) =&gt; &#123;  ...  console.log(&quot;通过SFTP传输文件到本地...&quot;);  const sftp = await promisify(conn.sftp.bind(conn))();  const __filename = fileURLToPath(import.meta.url);  const __dirname = path.dirname(__filename);  // 生成宿主机路径  const remoteFilePath = path.join(config.localDir, config.remoteFile).replaceAll(&quot;\\\\&quot;, &quot;/&quot;);  // 生成本地路径  const localFilePath = path.join(__dirname, config.remoteFile);  await promisify(sftp.fastGet.bind(sftp))(remoteFilePath, localFilePath);  console.log(&quot;文件传输到本地完成:&quot;, localFilePath);  console.log(&quot;删除Pod中的文件...&quot;);  await execCommand(    conn,    `cd $&#123;config.workDir&#125; &amp;&amp; kubectl --kubeconfig=$&#123;config.kubeConfig&#125; -n=$&#123;config.namespace&#125; exec $&#123;podName&#125; -- rm -f $&#123;config.remoteFile&#125;`  );  console.log(&quot;Pod中的文件删除完成&quot;);  console.log(&quot;删除宿主机上的文件...&quot;);  await execCommand(conn, `rm -f $&#123;config.localDir&#125;/$&#123;config.remoteFile&#125;`);  console.log(&quot;宿主机上的文件删除完成&quot;);&#125;;\n\n\n代码解析：\n\nreplaceAll为了确保生成的路径能够跨平台兼容\n还记得前面提到的每个exec都有独立的进程吗， 所有每次操作都要去进入到指定的目录\n\n\n","tags":["node"]},{"title":"react-router详解","url":"/blog/2024/05/24/react/react-router/","content":"基本使用\n通过BroserRouter 或者 HashRouter组件包裹要使用路由的根组件\nimport &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;...root.render(  &lt;StrictMode&gt;     &lt;BrowserRouter&gt;      \t&lt;App&gt;&lt;/App&gt;     &lt;/BrowserRouter&gt;  &lt;/StrictMode&gt;);\n\n使用Routes组件，定义路由显示区域, 类似 vue 里的router-view\nRoutes里面只能放Route；\n\n使用Route组件，定义具体路由规则\nimport Login from &quot;./views/login&quot;;import Layout from &quot;./layout&quot;;export default function App() &#123;  return (    &lt;&gt;      &#123;/* v5中Routes是写作Switch */&#125;      &lt;Routes&gt;         &#123;/* 注意二者引用组件方式的不同 */&#125;        &lt;Route path=&quot;/login&quot; element=&#123;&lt;Login /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/&quot; Component=&#123;Layout&#125;&gt;&lt;/Route&gt;      &lt;/Routes&gt;    &lt;/&gt;  );\n\n使用NavLink或者Link组件，定义跳转链接\n二者的区别就是切换后NavLink会给选中的元素添加 active 类\nimport &#123; ..., Link, NavLink &#125; from &quot;react-router-dom&quot;;...&lt;div&gt;    &lt;NavLink to=&quot;/login&quot;&gt;登录&lt;/NavLink&gt;    &lt;NavLink to=&quot;/&quot;&gt;主页&lt;/NavLink&gt;&lt;/div&gt;\n\n嵌套路由&lt;Routes&gt;  ...  &lt;Route path=&quot;/layout&quot; Component=&#123;Layout&#125;&gt;    &lt;Route path=&quot;page3&quot; Component=&#123;Page3&#125;&gt;&lt;/Route&gt;    &lt;Route path=&quot;page4&quot; Component=&#123;Page4&#125;&gt;&lt;/Route&gt;  &lt;/Route&gt;&lt;/Routes&gt;\n\n嵌套路由的出口：OutLet:\n// layout.jsximport &#123; ..., Outlet &#125; from &quot;react-router-dom&quot;;export default function Layout() &#123;  return (    &lt;div&gt;      &lt;div className=&quot;nav&quot;&gt;        &lt;NavLink to=&quot;/layout/page3&quot;&gt;page3&lt;/NavLink&gt;      &lt;/div&gt;      &lt;div className=&quot;main&quot;&gt;        &lt;Outlet&gt;&lt;/Outlet&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;\n\n动态路由&lt;Routes&gt;\t...,\t&lt;Route path=&quot;/page4/:id&quot; Component=&#123;Page4&#125;&gt;&lt;/Route&gt;&lt;/Routes&gt;\n\n访问的时候就必须带上带 id:\nhttp://localhost:5173/page4/4\n\n获取路由参数Params 参数\nv6- useParams , v5- this.props.match.params\nimport &#123; useParams &#125; from &quot;react-router-dom&quot;;export default function Page4() &#123;  let params = useParams();  // 可以拿到动态路由传递的参数  ...&#125;\n\nQuery 参数\nv6- useSearchParams , v5- this.props.location.search\nexport default function Page4() &#123;  const [query, seQuery] = useSearchParams();  query.get(&quot;id&quot;) // 这里就可以拿到/page4/4?id=6 中id的值  ...&#125;\n\nLocation 信息\nv6- useLocation , v5- this.props.location.state\nconst location = useLocation();console.log(location.pathname); // 可以获取到请求路径\n\n控制跳转地址v6- useNavigation ， v5 – this.props.history.push()\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;export default function Page3() &#123;  const navigate = useNavigate();  return (    &lt;&gt;      &lt;button        onClick=&#123;() =&gt;          navigate(&quot;/page4&quot;, &#123;            // 恒定state属性名            state: &quot;要被跳转地址location接收的参数&quot;,          &#125;)        &#125;      &gt;        跳转到page4      &lt;/button&gt;    &lt;/&gt;  );&#125;\n\n异步路由相当于路由懒加载\nimport &#123; lazy, Suspense &#125; from &quot;react&quot;;const lazyPage4 = lazy(() =&gt; import(&quot;./views/page4&quot;));...&lt;Suspense fallback=&#123;&lt;h2&gt;加载中&lt;/h2&gt;&#125;&gt;    ...    &lt;Route path=&quot;/page4&quot; Component=&#123;lazyPage4&#125;&gt;&lt;/Route&gt;    &lt;/Routes&gt;&lt;/Suspense&gt;\n\n配置生成路由这一节没有什么新的语法， 只是对前面的知识点进行整合。\n因为路由实际上是由组件来控制的， 那么我们通过配置表来渲染组件怎么样呢\n\n新建/router/index.js文件\nimport &#123; Navigate &#125; from &quot;react-router-dom&quot;;import Page1 from &quot;../views/page1&quot;;import Page2 from &quot;../views/page2&quot;;const routes = [  &#123;    path: &quot;/&quot;,    element: &lt;Navigate to=&quot;/login&quot;&gt;&lt;/Navigate&gt;,  &#125;,  &#123;    path: &quot;/page1&quot;,    element: &lt;Page1 /&gt;,  &#125;,  &#123;    path: &quot;/page2&quot;,    element: &lt;Page2 /&gt;,  &#125;,  // 处理未找到的页面  &#123;    path: &quot;*&quot;,    component: &lt;NotFound /&gt;,  &#125;,];export default routes;\n\n使用map生成 Route 组件\n&lt;Routes&gt;    &#123;    \troutes.map((item, index) =&gt; (    \t\t&lt;Route    \t\t\tpath=&#123;item.path&#125;    \t\t\telement=&#123;item.component&#125;    \t\t\tkey=&#123;item.path&#125;   \t\t\t &gt;   \t\t\t&lt;/Route&gt;    \t))    &#125;&lt;/Routes&gt;\n\n处理子路由\n// 将生成路由的方法抽离出来import &#123; Route &#125; from &quot;react-router-dom&quot;;export function createRoute(routes) &#123;  return routes.map((item, index) =&gt; &#123;    if (item?.children) &#123;      return (        &lt;Route path=&#123;item.path&#125; element=&#123;item.element&#125; key=&#123;item.path&#125;&gt;          &#123;createRoute(item.children)&#125;        &lt;/Route&gt;      );    &#125; else &#123;      return (        &lt;Route          path=&#123;item.path&#125;          element=&#123;item.element&#125;          key=&#123;item.path&#125;        &gt;&lt;/Route&gt;      );    &#125;  &#125;);&#125;\n\n处理子路由别忘记了Outlet;\n\n\n扩展： 导航守卫实现一个类似 vue 中beforeEach导航钩子的效果：\n// createRoute.jsximport &#123; useEffect &#125; from &quot;react&quot;; //核心...export function createRoute() &#123;  const &#123; pathname &#125; = useLocation();  const menu = useSelector((state) =&gt; state.userSlice.menu); // 获取菜单  const navigate = useNavigate();  const dispatch = useDispatch();  useEffect(() =&gt; &#123;    let token = localStorage.getItem(&quot;token&quot;);    if (token) &#123;      // 如果没有菜单数据      if (menu.length === 0) &#123;        dispatch(getUserInfo);      &#125;    &#125; else &#123;      // 路由是否在白名单内      if (whiteList.includes(pathname)) &#123;        navigate(pathname);      &#125; else &#123;        navigate(&quot;/login&quot;);      &#125;    &#125;  &#125;, [pathname]); // 监听路由的变化  // 返回路由组件  ...&#125;\n","tags":["React.js"]},{"title":"react-性能优化","url":"/blog/2024/05/31/react/react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"性能优化React 最大的一个性能问题是 —— 某个组件的 state 或 props 变化会触发整个函数的重新执行并且连带着他的子组件一起更新\n父组件：\nexport default function App() &#123;  const [count, setCount] = useState(0);  return (    &lt;&gt;      &lt;div&gt;count ： &#123;count&#125;&lt;/div&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击&lt;/button&gt;      &lt;Child&gt;&lt;/Child&gt;    &lt;/&gt;  );&#125;\n\n子组件：\nfunction Child() &#123;  console.log(&quot;子组件更新&quot;); // 父组件每次更新count都会触发  return &lt;&gt;child&lt;/&gt;;&#125;export default Child;\n\n解决办法： React.memo , 本质上是个高阶组件（类组件是PureComponent)\nexport default React.memo(Child);\n\n使用场景一般是props 不经常更新而且组件又存在较大的渲染开销\nprops如果组件已经使用了React.memo 或者PureComponent来实现如果父组件传递的 props 没改变，就不会更新。但是我们需要注意父组件传入的方法，对象，数组这样的引用类型。\nexport default function App() &#123;  const [count, setCount] = useState(0);  // 非state的引用值  let obj = &#123;    name: &quot;leihy&quot;,  &#125;;  function fn() &#123;    console.log(&quot;fn&quot;);  &#125;  return (    &lt;&gt;      ...      &lt;Child obj=&#123;obj&#125; fn=&#123;fn&#125;&gt;&lt;/Child&gt;    &lt;/&gt;  );&#125;\n\n在上面的代码中， 修改count的值仍在会触发子组件的更新, 因为obj和fn的被重新生成，引用地址变了——所以 props 的值也变了会触发更新；\n解决办法：\n\n用useCallBack包裹传递给子组件的方法\n非 state 对象，数组数据，要用useMemo包裹起来\n\n...let obj = useMemo(() =&gt; &#123;    return &#123;    \tname:&#x27;leihy&#x27;    &#125;&#125;,[])let fn = useCallback(function()&#123;    console.log(&#x27;fn&#x27;);&#125;,[])...\n\n再次修改count的值就不会引起子组件的更新了\n\ntips： 不是只要传给子组件的对象都要用 useMemo 包括起来，固定数据我们可以写在函数体外面；使用 useMemo 一般是需要根据 state 计算出某种状态的情况。\n\nstate避免 state 同样的值产生无意义更新， 类组件中使用PureComponent， 函数组件本身会判断\n扩展：缓存更新当使用useCallback, useMemo, useEffect方法时，如果函数体内依赖了某个 state 的数据，那么其一定要写在第二个参数中的数组中，否则拿不到最新的值；\nconst getNum = useCallback(() =&gt; &#123;  console.log(count);&#125;, [count]); // 如果不将依赖加入数组，count 永远是初始值\n","tags":["React.js"]},{"title":"react基础语法（class组件）","url":"/blog/2024/05/12/react/react%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"组件与 jsx组件类型分为函数组件与类组件 ， 作为组件使用名称必须以大写字母开头\nimport React from &quot;react&quot;;export default function App() &#123;  // 函数组件  function FnHello() &#123;    return &lt;div&gt;fnHello&lt;/div&gt;; // jsx - 一种能在js中书写的类html语法    // return React.createElement(&quot;div&quot;, [], &quot;hello&quot;);  也可以使用react提供的createElement  &#125;  // 类组件  class ClassHello extends React.Component &#123;    constructor(props) &#123;      super(props);    &#125;    render() &#123;      return &lt;div&gt;classHello&lt;/div&gt;;    &#125;  &#125;  return (    // 需要有一个根元素    &lt;div&gt;      &lt;FnHello /&gt;      &lt;ClassHello /&gt;    &lt;/div&gt;  );&#125;\n\njsx 内渲染不同内容的区别：\n...export default function App() &#123;  ...  let obj = &#123;    name = &#x27;leihy&#x27;  &#125;  return (    &lt;div&gt;      ...      &#123;&quot;hello&quot;&#125; &#123;/* string ：直接渲染 */&#125;      &#123;123&#125; &#123;/* number：直接渲染 */&#125;      &#123;obj&#125; &#123;/* Object ： 报错， jsx只能接受element对象（带尖括号） */&#125;      &#123;[1, 2, 3]&#125; &#123;/* Array: 会依次渲染里面的内容 */&#125;      &#123; 1+1 &#125; &#123;/* 表达式： 运行表达式 渲染运行结果 */&#125;      &#123; hello &#125; &#123;/* Function： 报错，只能渲染方法的执行结果 */&#125;      &#123; false &#125; Boolean：&#123;/* 无任何渲染 */&#125;      &#123;undefined&#125; undefined： &#123;/* 无任何渲染 */&#125;    &lt;/div&gt;  );&#125;\n\n本篇文章编写的代码都以类组件为基础\n事件绑定规则：\n\n类似于原生，on+方法名（首字母大写）\n事件必须接收一个方法（不要去执行）\n\nimport React from &quot;react&quot;;export default class App extends React.Component &#123;  hello() &#123;    console.log(this); // undefined  &#125;  bindHello() &#123;    console.log(this); // App实例  &#125;  arrowHello = () =&gt; &#123;    console.log(this); // App实例  &#125;;  render() &#123;    return (      &lt;div&gt;        // 注意：不作处理的情况下，this会指向`undefined`        &lt;button onClick=&#123;this.hello&#125;&gt;点击&lt;/button&gt;        // 可以使用bind个改变this指向        &lt;button onClick=&#123;this.bindHello.bind(this)&#125;&gt;点击&lt;/button&gt;        // 箭头函数也可以默认指向App实例        &lt;button onClick=&#123;this.arrowHello&#125;&gt;点击&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n其他操作：\n\n传递参数\n// 通过bind&lt;button onClick=&#123;this.bindHello.bind(this, 1, 2)&#125;&gt;点击&lt;/button&gt;\n\n获取事件对象\n// 未传参： 第一个参数bindHello(e) &#123;    // 并非原生的事件对象    console.log(e);&#125;&lt;button onClick=&#123;this.bindHello.bind(this)&#125;&gt;点击&lt;/button&gt;// 传参 ： 最后一个参数bindHello(a, b, e) &#123;    console.log(e);&#125;&lt;button onClick=&#123;this.bindHello.bind(this,1,2)&#125;&gt;点击&lt;/button&gt;\n\n可以理解为都是最后一个参数\n\n阻止默认行为，冒泡等\nbindHello(e) &#123;\t// 同原生事件    e.preventDefault;    e.stopPropagation;&#125;\n\n响应式数据定义与使用export default class ClassState extends React.Component &#123;  // 定义: 必须设为state， 否则修改数据无法响应  state = &#123;    name: &quot;leihy&quot;,  &#125;;  render() &#123;    return (      &lt;div&gt;        // 使用        &#123;this.state.name&#125;      &lt;/div&gt;    );  &#125;&#125;\n\n修改\nreact 的响应式数据为不可变值，不能直接修改\n需要使用 setState 函数去修改数据与触发更新\n\nhandleChange() &#123;    this.setState(&#123;      name: &quot;ll&quot;,  // 原理类似Object.assign,只需要加上要修改的属性就会合并    &#125;);&#125;&lt;button onClick=&#123;this.handleChange.bind(this)&#125;&gt; 改变姓名 &lt;/button&gt;\n\n注意： setState 是一个浅合并\nstate = &#123;    name: &#x27;leihy&#x27;,    obj: &#123;    \tsex: &#x27;male&#x27;,    \tage: 26    &#125;&#125;;handleChange() &#123;    this.setState(&#123;      name: &quot;ll&quot;,      obj:&#123;          ...this.state.obj,  // 修改深层对象属性时，一定要带上所有的属性          age: 18      &#125;    &#125;);&#125;\n\n获取修改后的值setState 方法是异步执行的\nhandleChange() &#123;    this.setState(&#123;\t\t...    &#125;);    console.log(this.state.name)  // 这里只能拿到旧值&#125;\n\n如果要拿修改后的值需要在 setState 的第二个参数里获取\nhandleChange() &#123;    this.setState(&#123; ... &#125;, () =&gt; &#123;    \tconsole.log(this.state) // 新值    &#125;);&#125;\n\nsetState 的一些特性：\n\nsetState 方法多次的多次修改，会合并为一次，统一修改\n\nsetState 返回会触发更新，不管你是否有修改，造成一个问题，重复修改为相同的值也会让组件更新\nrender() &#123;    console.log(&#x27;render&#x27;);  // 每次更新触发setState都会打印    return (     ...    );  &#125;\n\n解决办法：PureComponent\n\nPureComponent is similar to Component but it skips re-renders for same props and state\n\nexport default class ClassState extends React.PureComponent &#123; ... &#125;\n\nPureComponent的局限：修改引用类型的数据需要创建新的引用地址\nchangeArr() &#123;   this.state.arr.push(4);   this.setState(&#123;     arr: this.state.arr,  // 因为引用地址没变   &#125;); &#125;\n\n需要创建新的引用地址：\nchangeArr() &#123;\tlet newArr = cloneDeep(this.state.arr)   newArr.push(4);   this.setState(&#123;     arr: newArr,  // 正常更新   &#125;); &#125;\n\n一定不要在 render 里直接使用 setState, 会造成死循环\n\n\n条件渲染渲染原则：\n\nreact 渲染 undefined, null, 空字符串，false 风不会渲染任何内容\n如果渲染一个 jsx 编写的 html 元素，就会渲染成页面上的内容\n\n所以我们就可以通过编写一个 JS 逻辑运算， 通过返回不同的值来决定是否够渲染该内容；\nreturn (\t&lt;div&gt;\t    &#123;/* 三元运算 */&#125;\t\t&#123;this.state.isShow ? &lt;div&gt;要显示的内容&lt;/div&gt;&#125; : &#x27;&#x27;\t\t&#123;/* 与运算 */&#125;        &#123;this.state.isShow &amp;&amp; &lt;div&gt;要显示的内容&lt;/div&gt;&#125;\t&lt;div&gt;)\n\n列表渲染原则：\n\n渲染一个数组会把数组里的每个元素进行渲染\n那么我们编写一个里面存放的都是 html 结构的数组，就会渲染成列表\n\n所以我们可以使用纯函数在 jsx 中直接生成带有 jsx 的数组进行渲染：\nstate = &#123;  list: [    &#123; id: 1, name: &quot;Alice&quot; &#125;,    &#123; id: 2, name: &quot;Bob&quot; &#125;,    &#123; id: 3, name: &quot;Charlie&quot; &#125;,    &#123; id: 4, name: &quot;David&quot; &#125;,  ],&#125;;return (  &lt;div&gt;    &#123;this.state.list.map((item) =&gt; (      // key必传      &lt;div key=&#123;item.id&#125;&gt; &#123;item.name&#125; &lt;/div&gt;    ))&#125;  &lt;/div&gt;);\n\n当要指定渲染某些组件的时候可以使用filter + map\nreturn (  &lt;div&gt;    &#123;this.state.list      .filter((item) =&gt; item.id &gt; 2)      .map((item) =&gt; &#123;        return &lt;div key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/div&gt;;      &#125;)&#125;  &lt;/div&gt;);\n\n表单绑定获取表单输入值，可以通过监听 input，change 等事件，然后获取e.target.value\n如果要设置表单的值，通常设置 value 属性，如果是选择框则是 checked 属性等\ninput\nstate = &#123;    value: &quot;&quot;,&#125;;handleInput(e) &#123;    this.setState(&#123;      ...this.setState,      value: e.target.value,    &#125;);&#125;return (\t&lt;&gt;\t\t&lt;input          type=&quot;text&quot;          // 由于历史原因, react中使用change事件与input事件实现相同的功能          onChange=&#123;this.handleInput.bind(this)&#125;          value=&#123;this.state.value&#125;        /&gt;\t&lt;/&gt;)\n\ncheckbox\nhandleCheckbox(e) &#123;    // PureComponent需要重置对象引用地址    let selected = [...this.state.selected];    if (e.target.checked) &#123;        // e.target.value 拿到的是字符串        selected.push(e.target.value);    &#125; else &#123;        selected = selected.filter((item) =&gt; item !== e.target.value);    &#125;    this.setState(&#123;        ...this.state,        selected,    &#125;);&#125;return ( \t&#123;this.state.checkboxList.map((item) =&gt; &#123;        return (            &lt;div key=&#123;item.value&#125;&gt;                &lt;input                    type=&quot;checkbox&quot;                    name=&quot;fruit&quot;                    value=&#123;item.value&#125;                    checked=&#123;this.state.selected.includes(item.value)&#125;                    onChange=&#123;this.handleCheckbox.bind(this)&#125;                    /&gt;                &#123;item.label&#125;            &lt;/div&gt;        );\t&#125;)&#125;)\n\n组件传值（Props）在 react 中，一切写在组件上的属性和子节点都被规划为了 props。\n所以 props 是 react 很多功能的根本，父子传值，插槽全都是基于 props，不像 vue 有事件监听，emit，专门的插槽这等专门的功能；\n父传子import &#123; PureComponent &#125; from &quot;react&quot;;export default class Son extends PureComponent &#123;  // 如果有构造函数, 接受的值就是props  // constructor(props) &#123;&#125;  // 也可以直接在this上获取到  render() &#123;    return (      &lt;&gt;        &#123;this.props.name&#125;        // 父组件传递的元素都在children中(vue中的插槽)        &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;      &lt;/&gt;    );  &#125;&#125;\n\nprops 的类型验证和默认值类型验证：\n// 通用Son.propTypes = &#123;  name(props) &#123;    if (typeof props.name !== &quot;string&quot;) &#123;      throw new Error(&quot;type must be string&quot;);    &#125;  &#125;,  ... // 其他属性&#125;;\n\n但是这样验证起来也太麻烦了，我们可以使用proptypes库：\nimport PropTypes from &quot;prop-types&quot;;Son.propTypes = &#123;  name: PropTypes.string,  ...  // 是否必传（无默认值）  age: PropTypes.number.isRequired&#125;;\n\n默认值：\nSon.defaultProps = &#123;  name: &quot;default name&quot;,  ... // 其他属性&#125;;\n\n注意：在 react 19 中， 这两个属性的变化：\n\nIn React 19, we’re removing the propType checks from the React package, and using them will be silently ignored. If you’re using propTypes, we recommend migrating to TypeScript or another type-checking solution.\nWe’re also removing defaultProps from function components in place of ES6 default parameters. Class components will continue to support defaultProps since there is no ES6 alternative.\n\n// Beforeimport PropTypes from &quot;prop-types&quot;;function Heading(&#123; text &#125;) &#123;  return &lt;h1&gt;&#123;text&#125;&lt;/h1&gt;;&#125;Heading.propTypes = &#123;  text: PropTypes.string,&#125;;Heading.defaultProps = &#123;  text: &quot;Hello, world!&quot;,&#125;;// Afterinterface Props &#123;  text?: string;&#125;function Heading(&#123; text = &quot;Hello, world!&quot; &#125;: Props) &#123;  return &lt;h1&gt;&#123;text&#125;&lt;/h1&gt;;&#125;\n\n插槽slot实际上是 vue 的概念， 本质上就是讲子组件的 html 内容需要由父组件控制，我可以把 html 像普通的变量进行传递，而子组件通过props.children接收\n// app.jsxreturn (  &lt;div&gt;    &lt;Son&gt;      &lt;div&gt;这是子节点, 类似vue的插槽&lt;/div&gt;    &lt;/Son&gt;  &lt;/div&gt;);\n\n//Son.jsxreturn (  &lt;&gt;    &lt;div&gt; &#123;props.children&#125; &lt;/div&gt;  &lt;/&gt;);\n\n具名插槽： 实际上就是个 props 属性\n// 父组件&lt;Son headSlot=&#123;&lt;div&gt;具名插槽&lt;/div&gt;&#125;&gt;\t...&lt;/Son&gt;// 子组件&lt;div&gt; &#123;props.headSlot&#125; &lt;/div&gt;\n\n作用域插槽： 传一个函数过去接参\n// 父组件&lt;Son scopeSlot=&#123;(scope) =&gt; &lt;div&gt;作用域插槽拿到了值&#123;scope.name&#125;&lt;/div&gt;&#125;&gt;...&lt;/Son&gt;//子组件&lt;div&gt; &#123;props.scopeSlot(&#123; name: &quot;leihy&quot; &#125;)&#125; &lt;/div&gt;\n\n子传父子组件是不能直接去修改父组件的状态的，可以通过调用父组件传递的方法来修改；\n父组件：\n// 定义方法handleChildData(data) &#123;    ... // 更改状态等相关操作&#125;// 如果不传使用bind传递this， 那么this会指向props&lt;Son handleChildData=&#123;this.handleChildData.bind(this)&gt; ...&lt;/Son&gt;\n\n子组件最终调用prop.handleChildData就可以实现传值了\n兄弟传值eventbus ， 状态机等\n样式操作基础操作在react中， 可以有两个方式设置样式，分别是：\nclass 类名设置：\n\n属性名写为className\n类名和样式写在 Css 文件里\n必须接受一个字符串\n\nstyle 内联：\n\n不能像原生一样写成字符串，必须写成对象\n\n/* son.css */.title &#123;  color: red;&#125;.active &#123;  font-size: 30px;&#125;\n\nimport &quot;./son.css&quot;;...return (    &lt;&gt;     &lt;div className=&quot;title&quot;&gt; class样式 &lt;/div     // 原来带短横线的都改写为小驼峰     &lt;div style=&#123;&#123; fontSize: &quot;18px&quot; &#125;&#125;&gt; style样式 &lt;/div&gt; // 思考？为什么是双大括号    &lt;/&gt;)\n\nstyle 的样式是双括号，实际上是因为外层的括号表示接受一个 js，里面的表示一个对象；\n后续我们深入研究 class 样式。\n上面的 class 写法很简单，也有很多问题，比如import &quot;./son.css&quot;这样的引用实际上是全局生效的。\n我们可以使用.module.css限定生效范围：\nimport sonStyle from &quot;./son.module.css&quot;; // 实际引入的是一个对象console.log(sonStyle); // &#123;title: &#x27;_title_w2t0t_1&#x27;&#125;return (  &lt;&gt;    // 实际添加到dom上的类名是编译后的`_title_w2t0t_1`    &lt;div className=&#123;sonStyle.title&#125;&gt; class样式 &lt;/div&gt;  &lt;/&gt;);\n\n动态 class注意 : className 只能接收一个字符串。\n// 这样可就可以通过isActive的状态来控制样式&lt;div className=&#123;&quot;title &quot; + (this.state.isActive ? &quot;active&quot; : &quot;&quot;)&#125;&gt;     class样式&lt;/div\n\n但是问题也是显而易见的： 类名多了可读性不好；\n为了更好的可读性，可以使用classnames库：\n// 改写后import classNames from &quot;classnames&quot;;&lt;div className=&#123;\tclassNames(&#123;        title: true,        active: this.state.isActive,\t&#125;)&#125;&gt;\tclass样式&lt;/div\n\n到这里还有一个问题： module.css的书写：\nimport sonStyle from &quot;./son.module.css&quot;;// you may want to use the bind variantimport classNames from &quot;classnames/bind&quot;;let bindSonStyle = classNames.bind(sonStyle);return (  &lt;&gt;    &lt;div      className=&#123;bindSonStyle(&#123;        title: true,        active: this.state.isActive,      &#125;)&#125;    &gt;      class样式    &lt;/div&gt;  &lt;/&gt;);\n\n生命周期仅存在于类组件中，分为挂载，更新，卸载三大阶段\nconstructor: 初始化值\nrender: 决定要渲染的 dom，初始化及每次更新时触发\ncomponentDidMount : DOM 挂载完成时触发\nshouldComponentUpdate：更新时触发， 决定是否继续组件的更新（内置于PureComponent)\nshouldComponentUpdate() &#123;\t// 模拟PureComponent    if (newVal === oldValue) &#123;    \treturn false; // 就不在执行更新    &#125;    return true; // Make sure to return true or false.&#125;\n\ncomponentDidUpdate： 组件状态更新时触发, 如果shouldComponentUpdate返回 false 不执行；\ncomponentDidUnmount： 组件卸载时触发\n初始化顺序 ：constructor —&gt; render —&gt; componentDidMount\n更新顺序： shouldComponentUpdate —&gt; render —&gt; componentDidUpdate\nref用于获取真实 dom，与 vue 中的 ref 类似\n注意：\n\nref 必须在挂载后才能获取\n不能获取函数组件（因为没有实例）\n\nimport &#123; PureComponent, createRef &#125; from &quot;react&quot;;import Child from &quot;./components/child&quot;;let divEle = createRef&lt;HTMLDivElement&gt;();let childEle = createRef&lt;Child&gt;();class App extends PureComponent &#123;  componentDidMount(): void &#123;    console.log(divEle.current);    console.log(childEle.current);  &#125;  render() &#123;    return (      &lt;&gt;        &lt;div ref=&#123;divEle&#125;&gt;原生节点&lt;/div&gt;        &lt;Child ref=&#123;childEle&#125;&gt;&lt;/Child&gt;      &lt;/&gt;    );  &#125;&#125;\n\ncontext类似于 vue 的 provider 和 injected， 用于组件深层次的向下传值。\n我们需要做三步：\n\n创建一个context\n// App.jsximport &#123; createContext &#125; from &quot;react&quot;;export const LevelContext = createContext(&#123; a: 1 &#125;);\n\n从父组件传递指定的数据\n// App.jsx&lt;LevelContext.Provider value=&#123;&#123; a: 1 &#125;&#125;&gt;  &lt;Child&gt;&lt;/Child&gt;&lt;/LevelContext.Provider&gt;\n\n在需要该数据的地方使用该 context\n// GrandChild.jsx//类组件import &#123; LevelContext &#125; from &quot;../App&quot;;return (  &lt;&gt;    &lt;LevelContext.Consumer&gt;      &#123;(value) =&gt; &lt;div&gt;app传递的值: &#123;value.a&#125;&lt;/div&gt;&#125;    &lt;/LevelContext.Consumer&gt;  &lt;/&gt;);\n\n","tags":["React.js"]},{"title":"react-函数组件 && 高阶组件","url":"/blog/2024/05/22/react/%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%20&&%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/","content":"\n本章知识点需要以《react 语法基础（class 组件）》为基础\n\n函数组件基本概念前面的示例代码都是类组件，现在开始学习目前开发主流方式的函数组件；\n与类组件的区别：\n\n函数组件没有生命周期\n函数组件没有 this\n函数组件通过 hooks 来完成各种操作\n函数体相当于 render 函数\nprops 在函数的第一个参数接收\n\nuseState参考 ： https://react.dev/learn/state-a-components-memory\nuseEffect主要用于生命周期的模拟与监听等；\nuseEffect(callback, dependencies?)\n\n不传第二个参数 等于 componentDidMount和componentDidUpdate\n第二个参数传空数组 等于 componentDidMount\n第二个参数非传空数组 可以起到watch监听\nimport &#123;useState, useEffect &#125; from &#x27;react&#x27;;function GrandChild()&#123;    const [value, setValue] = useState(&#x27;hello&#x27;);    //初始化与任意状态变化都会触发    useEffect(() =&gt;&#123;        console.log(&#x27;effct&#x27;);    &#125;)    //初始化触发一次    useEffect(() =&gt;&#123;        console.log(&#x27;effct&#x27;);    &#125;, [])    //value变化的时候会触发    useEffect(() =&gt;&#123;        setValue(&#x27;world&#x27;);    &#125;, [value])    return ...;&#125;\n\n所以 callback 初始化时始终都会调用一次；\nuseMemo可以缓存渲染的计算结果，后续依赖的数据发生变化时才会重新运算；\n类似 vue 的computed\nconst valueFive = useMemo(() =&gt; &#123;  //should return a value of any type  return value + 5;&#125;, [value]); //value值改变的时候会触发\n\nuseCallback缓存一个方法，让方法不会每次更新重新创建\n案例： 配合memo实现子组件的非必要不更新\nimport React, &#123; useState, useCallback &#125; from &quot;react&quot;;export default function Example() &#123;  const [count, setCount] = useState(0);  const [age, setAge] = useState(18);  const increment = useCallback(() =&gt; &#123;    setCount(count + 1);  &#125;, [count]);  return (    &lt;div&gt;      Count: &#123;count&#125;      &lt;div&gt;age: &#123;age&#125; &lt;/div&gt;      &lt;button onClick=&#123;() =&gt; setAge(age + 1)&#125;&gt;修改年龄&lt;/button&gt;      &lt;Button onClick=&#123;increment&#125; /&gt;    &lt;/div&gt;  );&#125;interface ButtonProps &#123;  onClick: () =&gt; void;&#125;const Button: React.FC&lt;ButtonProps&gt; = React.memo((&#123; onClick &#125;) =&gt; &#123;  console.log(&quot;Button re-rendered&quot;);  return &lt;button onClick=&#123;onClick&#125;&gt;Increment&lt;/button&gt;;&#125;);\n\n\ntips： 上面提到的三个 hooks 的第二个参数用法基本一致，但是 useCallback 的应用主要是针对缓存机制，毕竟组件更新也不会触发函数。\n\nuseRef主要用于在函数组件中保存和访问 DOM 节点或组件实例\nimport &#123; useRef, useEffect &#125; from &quot;react&quot;;const divRef = useRef(0);useEffect(() =&gt; &#123;  console.log(&quot;divRef&quot;, divRef.current); //div节点&#125;, []);return &lt;div ref=&#123;divRef&#125;&gt;ref&lt;/div&gt;;\n\nuseContext读取并订阅从父级组件传递的value\nimport &#123; useContext &#125; from &quot;react&quot;;import &#123; LevelContext &#125; from &quot;../App&quot;;function GrandChild() &#123;  const value = useContext(LevelContext);  return &lt;&gt;child : &#123;value.a&#125;&lt;/&gt;;&#125;\n\n高阶组件（HOC）高阶组件（Higher Order Component，HOC）本质上是一种函数，并不是一种新的组件开发方式。\n它接受一个组件作为参数, 并返回一个新的增强版组件\n高阶组件可以用于在不改变原始组件代码的情况下，添加额外的功能或逻辑。\n这里我们实现一个获取屏幕定位的 HOC：\n\n定义locationHo.jsx\n\nimport &#123; useState, useEffect &#125; from &quot;react&quot;;export default function LocationHoc(MyComponent) &#123;  return function (props) &#123;    // 状态一定要定义在返回函数的内部    const [x, setX] = useState(0);    const [y, setY] = useState(0);    function update(e) &#123;      setX(e.clientX);      setY(e.clientY);    &#125;    useEffect(() =&gt; &#123;      addEventListener(&quot;mousemove&quot;, update);      return () =&gt; &#123;        // 卸载时销毁事件监听        removeEventListener(&quot;mousemove&quot;, update);      &#125;;    &#125;),      [];    return (      &lt;&gt;        ... // 也可以定义一些可复用的jsx        &lt;MyComponent x=&#123;x&#125; y=&#123;y&#125; props=&#123;&#123; ...props &#125;&#125; /&gt;      &lt;/&gt;    );  &#125;;&#125;\n\n\n使用高阶组件\nimport FnChild from &quot;./components/fnChild&quot;;import LocationHoc from &quot;./hoc/locationHoc&quot;;const FnChildHoc = LocationHoc(FnChild);...return (    &lt;&gt;    \t&lt;FnChildHoc/&gt;    &lt;/&gt;)就可以在子组件中服用`x`,`y`的值了：\n\n在子组件使用x,y的值:\n\n\nexport default function FnChild(props) &#123;  return (    &lt;&gt;      &lt;div&gt;x:&#123;props.x&#125;&lt;/div&gt;      &lt;div&gt;x:&#123;props.y&#125;&lt;/div&gt;    &lt;/&gt;  );&#125;\n\n有没有发现，这就是 vue 中的组合式函数\n","tags":["React.js"]},{"title":"Ts中的一些特殊机制","url":"/blog/2024/06/15/typescript/Ts%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E6%9C%BA%E5%88%B6/","content":"类型推断\n如果你没有定义类型，TypeScript 会根据值推断一个类型\n会根据你的代码执行结果上下文推断代码是否正确\n\nlet a = 1; // 被推断为number类型a = &quot;1&quot;; // Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;\n\n再比如在函数中：\n// 这里并没有设置返回类型， 但是会自动推断出为&#123;a: number&#125;function infer(a) &#123;  return &#123;    a: 1,  &#125;;&#125;\n\n类型兼容性如果两个东西结构相似，那么我们就认为他是一种类型\ninterface Obj &#123;  a: number;  b: number;&#125;let obj1 = &#123;  a: 1,  b: 2,  c: 3,&#125;;let obj2: Obj = obj1; // 被用于赋值的对象属性必须等于或包含被赋值对象\n\n上面提到的是对象的兼容，那么函数和类的兼容呢？\n函数let fn1 = (a: string, b: string) =&gt; &#123;&#125;;let fn2 = (c: string, d: string) =&gt; &#123;&#125;;fn1 = fn2;\n\n我们可以得出两个函数 只要形参数量一致，类型一致就可以进行赋值\n当然，被用于赋值的函数形参类型存在联合联系包含了被赋值的函数也是可以的， 反之不行\nlet fn1 = (a: number, b: string) =&gt; &#123;&#125;;let fn2 = (c: string | number, d: string) =&gt; &#123;&#125;;fn1 = fn2;\n\n类类的比较原则： 比较实例属性，不会比较构造函数与静态属性\nclass Person &#123;  name: string; // 只要实例属性一致  static age: number;  constructor(a: string, b: number) &#123;&#125;&#125;class Animal &#123;  name: string;  static weight: number;  constructor(c: number, d: string) &#123;&#125;&#125;let Mary: Person;let Tom: Animal;Mary = Tom!;\n\n类型保护也叫做类型窄化\n实现： 通过一些判断辅助 Ts 更准确地推断类型，避免一些报错\nfunction find(arr: (number | string)[] | string, target: string) &#123;  let result;  if (typeof arr === &quot;object&quot;) &#123;    // 如果没有这个判断， ts将认为arr使用forEach方法是错误的    arr.forEach((item) =&gt; &#123;      if (item === target) &#123;        result = item;      &#125;    &#125;);  &#125;  // ...  return result;&#125;\n\n扩展： symbol 与枚举很少用，了解\nsymbolsymbol代表不重复的内容，即使内容一样\nlet fooSymbol: symbol = Symbol(&quot;foo&quot;);let otherFooSymbol: symbol = Symbol(&quot;foo&quot;);console.log(genericSymbol == otherGenericSymbol); // false\n\n\n扩展：Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。\n\n枚举（enum）枚举就是一组按照顺序递增的数据。 也就是以第一个属性为起点逐个加 1（number 类型）。\nenum List &#123;  a = 1,  b, // 2  c, // 3&#125;\n\n看看编译为 js 文件的样子：\nvar List;(function (List) &#123;  List[(List[&quot;a&quot;] = 1)] = &quot;a&quot;;  List[(List[&quot;b&quot;] = 2)] = &quot;b&quot;;  List[(List[&quot;c&quot;] = 3)] = &quot;c&quot;;&#125;)(List || (List = &#123;&#125;));\n\n最终生成的List的结果就为：\n&#123; &#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;, a: 1, b: 2, c: 3 &#125;\n","tags":["TypeScript"]},{"title":"react- 全局状态管理","url":"/blog/2024/05/23/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","content":"\nWe do not currently have official React Native templates, but recommend these templates for standard React Native and for Expo:\n\nredux\n编写 reducer 方法\n给 state 默认值赋初始数据\n判断 type 修改数据\n调用legacy_createStore创建仓库\n\n// /store/index.jsimport &#123; legacy_createStore as createStore &#125; from &quot;redux&quot;;/** * @param &#123;*&#125; state 保存的状态 * @param &#123;*&#125; action 由dispatch传递过来的参数 * @returns */function reducer(state = &#123; password: &quot;admin123&quot; &#125;, action) &#123;  //类似于vue中的action  switch (action.type) &#123;    case &quot;changePwd&quot;:      state.password = action.payload.password;      return &#123; ...state &#125;;    default:      return state;  &#125;&#125;let store = createStore(reducer);export default store;\n\n使用：\n\n直接导入createStore生成的实例\n获取值： getState\n设置状态值： dispatch,\n\nimport store from &quot;./store&quot;;export default function App() &#123;  let state = store.getState();  return (    &lt;&gt;      &lt;div&gt;密码：&#123;state.password&#125;&lt;/div&gt;      &lt;button        onClick=&#123;          () =&gt;            store.dispatch(&#123;              type: &quot;changePwd&quot;,              payload: &#123; password: 123456 &#125;,            &#125;)          // 这里可以拿到最新的值        &#125;      &gt;        修改密码      &lt;/button&gt;    &lt;/&gt;  );&#125;\n\n上述代码虽然可以获取与修改状态值了，但是修改后页面却无法更新。\n因为此时 react 和 redux 还没有链接上。\nreact-redux\nReact-redux is the official React bindings layer for Redux.\n\n\n使用Provider组件包裹根组件\n// main.jsimport &#123; Provider &#125; from &quot;react-redux&quot;;let root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;);\n\n在connect方法传入根组件，并配置第一个参数\nimport &#123; connect &#125; from &quot;react-redux&quot;;...const createSotre = connect(  (state) =&gt; &#123;    return &#123; ...state &#125;; // 必须返回一个新对象, 返回的值会传递给传入组件的props  &#125;);export default createSotre(App);\n\n使用状态值：\nfunction App(props) &#123;  // props默认情况下会与connect传递对象进行属性合并，以及带有dispatch方法  return (    &lt;&gt;      &lt;div&gt;密码：&#123;props.password&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt;          props.dispatch(&#123;            type: &quot;changePwd&quot;,            payload: &#123; password: 123456 &#125;,          &#125;)        &#125;      &gt;        修改密码      &lt;/button&gt;    &lt;/&gt;  );&#125;\n\n至此已经实现了触发dispatch可以更新页面。\n\ntips：这样能够触发更新的根本原因是组件的 props 发生了改变，所以重新渲染页面了。\n\n不过如果给connect传入第二个方法，props 就不会再接收到 dispatch\nlet reactRedux = connect(  ...// 相当于直接对dispatch进行了封装  (dispatch) =&gt; &#123;    return &#123;      changePwd: function () &#123;        dispatch(&#123;          type: &quot;changePwd&quot;,          payload: &#123; password: 123456 &#125;,        &#125;);      &#125;,    &#125;;  &#125;);\n\n使用：\n&lt;button onClick=&#123;() =&gt; props.changePwd()&#125;&gt;修改密码&lt;/button&gt;\n\n模块化\n/store/index.jsimport &#123; legacy_createStore as createStore, combineReducers &#125; from &quot;redux&quot;;function userReducer(state = &#123; password: &quot;admin123&quot; &#125;,action) &#123;  ...&#125;function BusinessReducer(state = &#123; bid: 1 &#125;, action) &#123;  ...&#125;const reducers = combineReducers(&#123;     userReducer,     BusinessReducer, &#125;);export default createStore(reducers);\n\n在使用的时候需要在选择链上加上对应的名称：\n&lt;div&gt;密码：&#123;props.userReducer.password&#125;&lt;/div&gt;\n\ndispatch的使用不受模块化影响。\n但现在我们仍然还有很多问题…action 的逻辑，state 定义的方式等等令人感到迷惑\n@reduxjs&#x2F;toolkit\n… for efficient Redux development\n\n流程：\n\n创建切片\n整合切片，创建仓库\nReact-redux 链接到 react\n\n// /store/index.jsimport &#123; createSlice, configureStore &#125; from &quot;@reduxjs/toolkit&quot;;// 创建切片const userSlice = createSlice(&#123;  name: &quot;user&quot;,  initialState: &#123;    password: &quot;admin123&quot;,  &#125;,  reducers: &#123;    changePwd(state, action) &#123;      state.password = action.payload; // 在toolkit中必须以取&#x27;payload&#x27;属性    &#125;,  &#125;,&#125;);// 在组件里dispatch要调用的方法export const &#123; changePwd &#125; = userSlice.actions;// 整合切片const store = configureStore(&#123;  reducer: &#123;    userSlice: userSlice.reducer,    ... // 如果有多个切片  &#125;,&#125;);export default store;\n\n组件中调用 dispatch：\n//App.jsximport &#123; changePwd &#125; from &quot;./store/toolkit&quot;;...&lt;button onClick=&#123;() =&gt; props.dispatch(changePwd(&quot;123456&quot;))&#125;&gt;  //toolkit的用法\n\n到这里为止，一套简洁，完整的状态管理流程就已经完成了。但是我们一般只是将这种方式用在class组件当中.\n函数组件使用useSelector和useDispatch\n函数组件注意： hook 只能在 toolkit 和函数组件中使用\nimport &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import &#123; incremented &#125; from &quot;./store/toolkit&quot;;function App() &#123;  const count = useSelector((state) =&gt; state.counterSlice.count);  const dispatch = useDispatch();  return (    &lt;&gt;      &lt;div&gt; count : &#123;count&#125;&lt;/div&gt;      &lt;button onClick=&#123;() =&gt; dispatch(incremented())&#125;&gt;点击+1&lt;/button&gt;    &lt;/&gt;  );&#125;export default App;\n\n在使用 hooks 的组件里，连connect方法的使用也省去了。\n异步如果我们存在异步需求，不能直接定义在 reducer 里，需要createAsyncThunk配合extraReducers实现\n// /store/index.jsimport &#123;..., createAsyncThunk &#125; from &quot;@reduxjs/toolkit&quot;;export let getCountChunk = createAsyncThunk(&quot;getCounterCount&quot;, (params) =&gt; &#123;  // must return a promise  return new Promise((resolve, reject) =&gt; &#123; // 实际开发中一般就是接口请求    setTimeout(() =&gt; &#123;      resolve(10);    &#125;, 1000);  &#125;);&#125;);const counterSlice = createSlice(&#123;  ... ,   extraReducers: (chunk) =&gt; &#123;    chunk.addCase(      getCountChunk.fulfilled,      /**       * @param &#123;*&#125; state 该切片的状态       * @param &#123;*&#125; action Promise中resolve抛出的值       */      (state, action) =&gt; &#123;        state.count = action.payload;      &#125;    )      .addCase(getCountChunk.rejected, () =&gt; // 执行失败的逻辑)  &#125;,&#125;);...\n\n使用该异步 chunk：\n&lt;button onClick=&#123;() =&gt; dispatch(getCountChunk(params))&#125;&gt;\n\n到这里， redux 状态管理的知识点就圆满结束啦~\n","tags":["React.js"]},{"title":"React必踩坑及其背后原理","url":"/blog/2024/06/08/react/React%E5%BF%85%E8%B8%A9%E5%9D%91%E5%8F%8A%E5%85%B6%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86/","content":"基础知识react 的存在一个更新问题——state 的更新会重新执行整个函数以及更新子组件\n我们可以使用React.memo来阻止子组件的更新\nexport default React.memo(Component);\n\n但是上面我们提到，组件状态的更新会导致整个函数重新执行。\n那么引用类型的值就会被重新创建（内存地址），比如非 state 的对象，函数等\n如果一个方法被传递给子组件：\nconst getList = async () =&gt; &#123;  // 调用接口&#125;;return (  &lt;&gt;    &lt;Filter getList=&#123;getList&#125;&gt;&lt;/Filter&gt;  &lt;/&gt;);\n\n该方法在每次组件更新时就会被重新创建，从而导致子组件也会更新。\n我们可以使用useCallback将要传递给子组件的方法包裹起来：\nimport &#123; useCallback &#125; from &quot;react&quot;;...const getList = useCallback(() =&gt; &#123;\t// 调用接口&#125;, []);\n\n这时候当前组件的更新就不会再导致方法重新创建，从而减少更新。\n对象也是同理，只不过要使用useMemo包裹：\nconst person = useMemo(() =&gt; &#123;  // must return sth  return &#123;    name: &quot;leihy&quot;,  &#125;;&#125;, []);&lt;Filter person=&#123;person&#125;&gt;&lt;/Filter&gt;;\n\n注意：由组件数据计算而来的值才需使用useMemo\n\ntips:\n​ 切勿滥用useCallback和useMemo，比如不会改变的对象也可以放在函数体之外，传给子组件的方法才需要包裹等；\n\n我们感受到了缓存的强大，但是也得注意一些问题：\n如果使用了在useMemo, useCallback中使用了 state 的数据，那么一定要在依赖数组中加他，否则会导致一直拿到的是开始缓存的值。\nconst getList = useCallback(() =&gt; &#123;  console.log(count); // 可以正常拿到count&#125;, [count]);const person = useMemo(() =&gt; &#123;  return &#123;    name: &quot;leihy&quot;,    age: count, // 传递给子组件的count永远是初始值  &#125;;&#125;, []);\n\n实践react 的 state 还有个经典的闭包问题导致拿不到新数据\n现在我们有一个需求：\n\n一个计数器，在父组件\n搜索栏，为子组件\n页面组件，为子组件\n\n上述功能修改时都会调用接口并携带每个组件的数据（某个方法）\n代码初步设计：\nimport &#123; useCallback, useState, useMemo &#125; from &quot;react&quot;;import Pagination from &quot;../components/Pagination&quot;;import Filter from &quot;../components/Filter&quot;;export default function Dashboard() &#123;  const [count, setCount] = useState(1);  const [inputData, setInput] = useState(&quot;&quot;);  const add = () =&gt; &#123;    setCount(count + 1);  &#125;;  // 子组件切换页面或者点击搜索触发  const getList = useCallback(    (pageData) =&gt; &#123;      console.log(count, inputData, pageData);    &#125;,    [count, inputData]  );  return (    &lt;&gt;      &lt;div&gt;count: &#123;count&#125;&lt;/div&gt;      &lt;button onClick=&#123;add&#125;&gt; 增加count &lt;/button&gt;      &lt;Filter getList=&#123;getList&#125; setInput=&#123;setInput&#125;&gt;&lt;/Filter&gt;      &lt;Pagination getList=&#123;getList&#125;&gt;&lt;/Pagination&gt;    &lt;/&gt;  );&#125;\n\nFilter组件：\nimport React from &quot;react&quot;;function Filter(props) &#123;  const &#123; getList, setInput &#125; = props;  const handleClick = () =&gt; &#123;&#125;;  const handleChange = (e) =&gt; &#123;    setInput(e.target.value);  &#125;;  return (    &lt;&gt;      &lt;input type=&quot;text&quot; onChange=&#123;handleChange&#125; /&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;搜索&lt;/button&gt;    &lt;/&gt;  );&#125;export default React.memo(Filter);\n\nPagination组件：\nimport React from &quot;react&quot;;function Pagination(props) &#123;  const &#123; getList &#125; = props;  return (    &lt;&gt;      &lt;div&gt;        &#123;[1, 2, 3, 4].map((item) =&gt; &#123;          return (            &lt;button key=&#123;item&#125; onClick=&#123;() =&gt; getList(item)&#125;&gt;              &#123;item&#125;            &lt;/button&gt;          );        &#125;)&#125;      &lt;/div&gt;    &lt;/&gt;  );&#125;export default React.memo(Pagination);\n\n看似很完美，但还是有点性能问题，那就是如果父组件中的count或者inputData变化了，仍然会让所有应用了getList的子组件重新更新。\n这里还是推荐使用副作用方案：\nuseEffect(() =&gt; &#123;  getList();&#125;, [count, inputData, pageData]);\n\n然后在子组件调用各自的setState方法， 这个时候子组件就不会再被父组件的更新所影响了。\n例如：\nfunction Filter(props) &#123;  const &#123; setInput &#125; = props;  const inputValue = useRef(&quot;&quot;); // 减少页面更新  const handleClick = () =&gt; &#123;    setInput(inputValue.current);  &#125;;  const handleChange = (e) =&gt; &#123;    inputValue.current = e.target.value;  &#125;;  return (    &lt;&gt;      &#123;/* 如果要失焦就能拿到数据使用blur时间 */&#125;      &lt;input type=&quot;text&quot; onChange=&#123;handleChange&#125; /&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;搜索&lt;/button&gt;    &lt;/&gt;  );&#125;\n\n\ntips： 要回避闭包缓存也可以使用useRef来存储数据，但其变化不会触发页面更新\n\n","tags":["React.js"]},{"title":"Ts的工程化编译","url":"/blog/2024/06/15/typescript/ts%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%BC%96%E8%AF%91/","content":"\n本节中所举例的构建工具为 webpack\n\n要实现 TS 编译有两个关键点：\n\nTs-loader 用来在打包的时候处理 TS 文件(实质上就是调用typescript这个库)\ntsconfig 用来调控如何编译 TS\n\n基础实现\nnpm初始化\nnpm init -y\n\n新建app.ts\nlet age: number = 25;\n\n新建webpack.config.ts\nmodule.exports = &#123;  mode: &quot;development&quot;,  entry: &#123;    app: &quot;./app.ts&quot;,  &#125;,  output: &#123;    path: __dirname + &quot;/dist&quot;,    filename: &quot;[name].js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\\.tsx?$/,        use: &quot;ts-loader&quot;,      &#125;,    ],  &#125;,&#125;;\n\n这时候如果执行编译， 会报错找不到tsconfig.json，那么新建tsconfig.json\n// 就算是空的也会按照默认配置进行编译...\n\n执行npm run build, 编译成功\n\n\n&gt; typescript@1.0.0 build&gt; webpackasset app.js 1.16 KiB [compared for emit] (name: app)./app.ts 14 bytes [built] [code generated]webpack 5.92.0 compiled successfully in 720 ms\n\n\n看看编译后的代码：\n// app.jseval(&quot;var age = 25;\\n\\n\\n//# sourceURL=webpack://typescript/./app.ts?&quot;);\n\n声明文件两个作用：\n\n当我们引入了一个库，这个库如果没有声明文件，会被当成any\nJS 中我们可以把一些东西挂载在全局，然后另一个模板获取，但是这在 TS 中是有问题的\n\n先来看第一个作用，我们安装axios与 lodash， 然后引入。后者是没有声明文件的。\nimport * as _ from &quot;lodash&quot;;  //Could not find a declaration file for module &#x27;lodash&#x27;import axios from &quot;axios&quot;;\n\n在 TS 中引入lodash就会出现上面的提示，虽然不会产生运行时的直接影响，但会出现一些问题，具体表现在；\n\n无法提供准确的智能提示和补全\n如果启用了严格模式（strict: true），缺少声明文件会导致编译时报错，阻止 TypeScript 生成 JavaScript 文件\n\n我们可以安装@types/lodash来进行处理；node_modules中的@types文件夹就会包含对应的声明文件\n\ntips： 当安装第三方声明文件时， 常用的格式都是 @types/packageName\n\n然后是获取全局数据时的第二个作用。\n当我们挂载一个全局数据：\nwindow.token = &quot;ssdasd&quot;;\n\n但是我们在 TS 文件中使用的时候：\nconsole.log(token);  // Cannot find name &#x27;token&#x27;\n\n因为在当前文化中是没有token这个变量，但是代码实际运行也不会报错。\n那么如何解决这个报错？\n通过.d.ts文件，该文件可放在任意能够被 TypeScript 编译器能够正确找到的地方。\n// global.d.tsdeclare let token: string;declare type userType = string;// 接口，类等等...\n\n然后在全局文件中使用相关变量或类型就不会报错了\nconsole.log(a);let me: userType = &quot;leihy&quot;;\n\ntsconfig 配置&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;esnext&quot;, // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (默认), &#x27;ES5&#x27;, &#x27;ES6&#x27;/ES2015, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNext&#x27;    &quot;module&quot;: &quot;esnext&quot;, // 指定模块代码生成: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;esnext&#x27;    &quot;strict&quot;: true, // 启用所有严格类型检查选项    &quot;jsx&quot;: &quot;preserve&quot;, // 保留 JSX 语法    &quot;importHelpers&quot;: true, // 启用导入助手函数以减少代码重复    &quot;moduleResolution&quot;: &quot;node&quot;, // 告诉编译器采用模块解析策略: &#x27;node&#x27; (Node.js) 或 &#x27;classic&#x27; (TypeScript pre-1.6)    &quot;experimentalDecorators&quot;: true, // 启用实验性的装饰器特性    &quot;esModuleInterop&quot;: true, // 允许对 ES 模块的默认导入    &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有设置默认导出的模块中默认导入    &quot;sourceMap&quot;: true, // 生成相应的 &#x27;.map&#x27; 文件    &quot;baseUrl&quot;: &quot;.&quot;, // 设置解析非相对模块名称的基目录    &quot;types&quot;: [&quot;webpack-env&quot;, &quot;node&quot;], // 指定要包含在编译中的类型定义文件    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [&quot;src/*&quot;] // 设置路径映射，使 `@/` 映射到 `src/` 目录    &#125;,    &quot;lib&quot;: [      &quot;esnext&quot;, // 包含最新的 ECMAScript 标准库      &quot;dom&quot;, // 包含 DOM 类型定义      &quot;dom.iterable&quot;, // 包含可迭代的 DOM 类型定义      &quot;scripthost&quot; // 包含脚本宿主的类型定义    ]  &#125;,  &quot;include&quot;: [    &quot;src/**/*.ts&quot;,    &quot;src/**/*.tsx&quot;,    &quot;src/**/*.vue&quot;,    &quot;tests/**/*.ts&quot;,    &quot;tests/**/*.tsx&quot;  ],  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]&#125;\n\n上面是vue-cli所生成的文件配置，具体后续再作解析。\n","tags":["TypeScript"]},{"title":"ts的意义与麻烦","url":"/blog/2023/12/30/typescript/ts%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E9%BA%BB%E7%83%A6/","content":"意义最大的意义就是避免写错变量名，方法名，屏蔽掉低级错误\n\n编写一些公用方法和全局配置对象，用于提醒使用者传参的 key 值和 value 类型等\n//apis/users.tsexport interface ListParamsType &#123;    pageNum: number,    pageSize: 10 | 30 | 50  //字面量&#125;export const getList = (params:ListParamsType)=&gt; &#123;    ...这里请求数据&#125;\n\n声明组件 props\n减少传参错误，以及一些不必要的 TS 报错\ninterface Props &#123;  item: RouteRecordRaw;  basePath?: string;&#125;const props = withDefaults(defineProps&lt;Props&gt;(), &#123;  basePath: &quot;&quot;,&#125;);\n\n一些使用 TS 编写的第三方库，在使用的时候可以检查有没有调错方法等\n这里以 Vue-Router 为例：\n//router/index.tsconst router = createRouter(&#123;  history: createWebHistory(),  routes: [    &#123;      path: &quot;/login&quot;,      //如果你没有传必需的component属性则会报错      //Type &#x27;&#123; path: string; &#125;&#x27; is not assignable to type &#x27;RouteRecordRaw&#x27;.    &#125;,  ],&#125;);\n\n麻烦\n阶段类型不匹配\n调用初始化为空对象的但是后来会被赋值的属性：\n//SidebarItem.vue&lt;template&gt;    &lt;div v-if=&quot;!item.hidden&quot;&gt;        &lt;template v-if=&quot;hasOneShowingChild(item.children,item)&quot;&gt;             &lt;!-- Property &#x27;path&#x27; does not exist on type &#x27;&#123;&#125;&#x27; --&gt;            &lt;el-menu-item :index=&quot;onlyChild.path&quot;&gt;                &lt;!-- Property &#x27;title&#x27; does not exist on type &#x27;&#123;&#125;&#x27; --&gt;                &#123;&#123; onlyChild.meta.title &#125;&#125;            &lt;/el-menu-item&gt;        &lt;/template&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;;let onlyChild = reactive(&#123;&#125;);  //就算在代码执行过程中赋值，但是调用处仍然报错&lt;/script&gt;\n\n我们对页面上会调用的变量进行类型定义并断言\n&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;;interface OnlyChildType &#123;    meta:&#123;        title:string    &#125;,    path:string&#125;let onlyChild = reactive(&#123;&#125; as OnlyChildType);&lt;/script&gt;\n\n这个时候去调用meta, path等属性就不会有错误提示了\n\nTS 编写的第三方库时，需要定义某个参数为库的某个类型\n我们定义了一个动态添加路由的方法，会出现如下报错\n//Parameter &#x27;routes&#x27; implicitly has an &#x27;any&#x27; typefunction addRoute(routes) &#123;  routes.forEach((route) =&gt; &#123;    router.addRoute(route);  &#125;);&#125;\n\n可是要传入第三方库的参数类型我们该怎么定义？\n一般来说，编写较为规范的库都会直接暴露出对应的 TS 类型可以让我们直接导入\nimport type &#123; RouteRecordRaw &#125; from &quot;vue-router&quot;;//这个时候使用引入的类型就非常完美了function addRoute(routes: RouteRecordRaw[]) &#123;  routes.forEach((route) =&gt; &#123;    router.addRoute(route);  &#125;);&#125;\n\n但是，如果如果不规范的库无法直接导入怎么办？\n​ a.这里我们还是以 Vue-Router 为例，通过 node_modules 找到对应库根目录的package.json\n​ b.找到其types属性，该属性指向使用import type 导入类型时所查找的位置\n​ c.然后找到对应的类型查看其如何定义\n\n一些常见的 DOM 类型报错\n这里以渲染节点文本的内容为例子\n\n\n&lt;div @click=&quot;(e)=&gt;&#123;        let target = e.target        //Property &#x27;innerText&#x27; does not exist on type &#x27;EventTarget&#x27;        target.getContext(&#x27;2D&#x27;)  //因为dom的类型推论错误    &#125;&quot;&gt;&lt;/div&gt;\n\n​ 这时候加上正确的类型断言：\n&lt;div @click=&quot;(e)=&gt;&#123;    let target = e.target as HTMLElement    target.innerTExt = &#x27;test&#x27;&#125;&quot;&gt;\n\n​ 完美解决~\n","tags":["TypeScript"]},{"title":"axios二次封装","url":"/blog/2024/04/15/vue3/axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/","content":"\n核心内容：\n\n通用的 axios 基本封装方案\n大厂的一些特殊操作\n配置中心的理念\n\n\n基础封装import axios from &#x27;axios&#x27;import &#123; whiteListApi, statuCodes &#125; from &#x27;./constant/service&#x27;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()let service = axios.create(&#123;  // 1. 基础配置  baseURL: &#x27;http://localhost:5000/&#x27;,  timeout: 5000,  responseType: &#x27;json&#x27;, //默认值  headers: &#123;&#125;&#125;)service.interceptors.request.use((request) =&gt; &#123;  let url = request.url as string  let token = localStorage.getItem(&#x27;token&#x27;)  if (!whiteListApi.includes(url)) &#123;    request.headers.token = JSON.parse(token as string)  &#125;  return request&#125;)// 响应的统一基本处理service.interceptors.response.use(  (response) =&gt; &#123;    const &#123; code, message &#125; = response.data    if (code === statuCodes.unauthorized) &#123;      ElMessage.error(message)      router.push(&#x27;/login&#x27;)      return Promise.reject(new Error(message)) // 由接口调用处决定是否需要进一步处理错误    &#125;    if (code !== statuCodes.success) &#123;      ElMessage.error(message)      return Promise.reject(new Error(message))    &#125;    return response  &#125;,  (error) =&gt; &#123;    ElMessage.error(error.message)    return Promise.reject(new Error(error.message))  &#125;)export default service\n\n封装请求方法// user.tsimport &#123;request&#125; from &#x27;./request&#x27;export const getUserList = () =&gt; &#123;  return request(&#123;    url: &#x27;/api/getList&#x27;,    method: &#x27;get&#x27;  &#125;)&#125;// App.vue&lt;script setup&gt;import &#123; getUserList &#125; from &#x27;@/apis/users&#x27;// 后续根据业务进行使用&lt;script/&gt;\n\n扩展防止频繁提交// request.tsimport request from &quot;@/axios&quot;;const throttleRequest = (function () &#123;  let hasRequest: string[] = [];  return function (config: any) &#123;    let url = config.url;    if (hasRequest.includes(url)) &#123;      return Promise.reject(&quot;请勿重复提交请求&quot;);    &#125;    hasRequest.push(url);    return request(&#123; ...config &#125;)      .then((res) =&gt; &#123;        return res;      &#125;)      .finally(() =&gt; &#123;        // 不会被then中的return中止        hasRequest = hasRequest.filter((requestUrl) =&gt; requestUrl !== url);      &#125;);  &#125;;&#125;)();export &#123; request, throttleRequest &#125;;\n","tags":["vue3"]},{"title":"TypeScript基础语法","url":"/blog/2024/06/13/typescript/typescript%E5%9F%BA%E7%A1%80/","content":"\n记哪些？\n\n各种类型的写法和操作\nTypescript 一些机制\n一些关键字怎么用\n\n理解哪些？\n\n工程化的配置\n一些实战中常见需求怎么去描述类型\n编写一些常见的东西\n\n\n为什么需要 TypeScript？项目需要编写一个全局数组排序方法\n写了一个组件，该组件的事件必须具有一个特定的参数\n调试工具ts-node : 模拟浏览器环境typescript : 将 ts 文件编译为 js 文件\n当然，这两个工具仅用于自己学习使用，实战中的构建工具都已经处理好了。\n基础类型\n本节要点：\n\nstring，number，boolean，null，undefined 等基础类型\ntypescipt 如何限定一个变量的类型\n字面量类型\n\n\nstringlet str: string = &quot;leihy&quot;;//如果要设置number类型str = 123;//Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;\n\nnumberlet b: number = 123;\n\nbooleanlet c: boolean = true;\n\n\ntips： 当存在 tsconfig.json 文件时，会默认关闭严格模式，此时就可以将 undefine，null 赋值给各类型\n\n字面量// 内容都被限定了let ENV: &quot;dev&quot; | &quot;prod&quot; | &quot;test&quot; = &quot;dev&quot;;\n\n联合类型// 只能是文本或数字let test: string | number = &quot;123&quot;;\n\n引用类型数组// 纯(数字）类型let arr1: number[] = [1, 2, 3];// 泛型定义let arr2: Array&lt;number&gt; = [1, 2, 3];// 元组: 指定位置必须有指定类型的元素, 不能多与少let arr2: [string, number] = [&quot;1&quot;, 2];\n\n对象let obj: &#123; x: number; y: number &#125; = &#123; x: 1, y: 2 &#125;;\n\n案例扩展// 元素是字符串或字符串let arr1: (number | string)[] = [1, &quot;2&quot;];// 数组中有一个元素是可有可无的let arr2: [string, number?] = [&quot;1&quot;];// 数组中前面固定，后面可以随意添加let arr3: [string, number, ...(number | string)[]] = [&quot;1&quot;];// 规定键名是一个数字let obj1: &#123; [propsName: number]: number &#125; = &#123; 123: 111, 456: 1323 &#125;; // 可以发现其他数字键名可以不用再声明了// 属性可有可无let obj2: &#123; x: number; y?: number &#125; = &#123; x: 1 &#125;;// 固定某几个属性，其他属性随便加let obj3: &#123; x: number; y: number; [propsName: string]: string &#125; = &#123;  x: 1,  y: 2,  name: &quot;123&quot;,&#125;;\n\n\ntips—— 可选\nts 中经常用?号来属性可选，比如对象中可选属性，方法中可选参数\n\n函数// 直接定义一个函数的参数与返回function fn1(a: string): string &#123;  return &quot;abc&quot;;&#125;// 定义一个变量为函数类型let fn2: (a: string) =&gt; string = function (b) &#123;  return &quot;123&quot;;&#125;;\n\n实际应用\n参数可选 + 剩余参数处理\n\nfunction fn1(a: string, b?: string, ...args: number[]): string &#123;  console.log(args); // 获取所有没有被显式接收的参数  return &quot;abc&quot;;&#125;// 编译为jsfunction fn1(a, b) &#123;  var args = [];  for (var _i = 2; _i &lt; arguments.length; _i++) &#123;    args[_i - 2] = arguments[_i];  &#125;  console.log(args);  return &quot;abc&quot;;&#125;\n\n\n默认值：参数类型由默认值的类型推断， 并且带有可选的含义了\n\nfunction fn1(a = 1): number &#123;&#125;\n\n\nthis 处理：\n\nfunction fn3(this: void, a: string) &#123;  // 函数内就正常使用this&#125;fn3(&quot;hi&quot;); // 传递的参数会被a接收到\n\n类（class）js 对比 ts 的 class\n\n\n\njs\nts\n\n\n\n公有属性\n默认共有\n默认公有，多了 public（默认）\n\n\n私有属性\n无直接实现\nprivate\n\n\n静态属性\n无直接实现，提案有 static\nstatic\n\n\n只读\n无直接实现\nreadonly\n\n\nprotected\n无直接实现\nprotected\n\n\n// test.tsclass TSClass &#123;  pub = 1; // 公有属性  private pri = 2;  static sta = 3;  readonly read = 4;  protected pro = 5;  fn() &#123;    this.pro = 7; // 只能在类中修改与读取  &#125;&#125;// 静态属性只能在类上获取console.log(TSClass.sta); // 3let test = new TSClass();test.pri; //Property &#x27;pri&#x27; is private and only accessible within class &#x27;TSClass&#x27;test.sta; // Property &#x27;sta&#x27; does not exist on type &#x27;TSClass&#x27;test.sta = 5; // Cannot assign to &#x27;read&#x27; because it is a read-only property\n\n类型定义class TSClass &#123;  name: string;  fn(count: number): number;  fn(count) &#123;    return count + 1;  &#125;  constructor() &#123;    this.name = &quot;leihy&quot;;    this.age = 25; // Property &#x27;age&#x27; does not exist on type &#x27;TSClass&#x27;.  &#125;&#125;\n\n\ntips: 定义了类型的 class 还可以当作接口以限制对象的属性类型\n\n特殊类型与高级类型any &amp;&amp; unknow\nany 和 unkow 类型可以分配任何值\nunknown 相当于更安全的 any， unkown 类型只能赋值给 unkown 和 any\n\nlet value1: any = 123;let value2: unknown = &quot;123&quot;;let value3: string = value1;let value4: string = value2; // type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;.\n\n\ntips: 不可随意滥用 any 与 unkown 类型， 否则 ts 就失去了本身的意义\n\nnever（了解）\nnever 代表永远不会出现\nnever 类型的变量可以赋值给任何东西，但 never 类型不能有任何值\n常用错误类型，或者永远没有结果的返回值\n\nfunction throwError(): never &#123;  throw new Error(&quot;error&quot;);&#125;\n\n联合类型满足其中一种类型, 使用管道符|定义\nlet arr: (string | number)[];\n\n交叉类型必须满足多个类型，一般用于两种不对的对象，使用连字符&amp;\nclass obj1Class &#123;  a: number;&#125;class obj2Class &#123;  b: number;&#125;let obj3: obj1Class &amp; obj2Class = &#123;  a: 1,  b: 2,&#125;;\n\n接口与 typetype\ntype关键字用于给一个类型一个命名，可以用于各种类型的定义。\n\n常用于基础类型和联合，交叉类型。方便复用\ntype dataType = number | string | number[];type obj1 = &#123;  a: number;&#125;;type obj2 = &#123;  b: number;&#125;;type obj3 = obj1 &amp; obj2;let obj: obj3 = &#123;  a: 1,  b: 2,&#125;;// 定义函数type f1 = (a: string) =&gt; string; // a只是一个占位符let fn: f1 = (b: string) =&gt; &#123;  return &quot;1&quot;;&#125;;\n\ninterface\ninterface意思为接口，区别于 type，这是定义了一个可继承的接口\n常用于函数，类，对象，数组的定义\n\n对象interface UserInfo &#123;  name: string;  id: number;&#125;function handleInfo(userInfo: UserInfo) &#123;  userInfo.name.slice(0); // 这个时候就能自动推导出name属性所拥有的的api&#125;handleInfo(&#123; name: &quot;leihy&quot;, id: 1 &#125;);\n\n函数interface obj &#123;  a: number;  fn: (b: string) =&gt; string;  //对象内函数&#125;let obj:Obj = &#123;  a: 1,  fn(b)&#123;    return &#x27;1&#x27;  &#125;  // 也可以写成：  fn2(b: string): string;&#125;// 直接定义函数类型interface Fn &#123;  (a: string, b: string): string;&#125;let fn: Fn = (a, b) =&gt; &#123;  return a + b;&#125;;\n\n类interface Person &#123;  age: number;  sex: &quot;male&quot; | &quot;female&quot;;  eat(food: string): string;&#125;class Mary implements Person &#123;  age: number;  sex: &quot;male&quot; | &quot;female&quot;;  eat(food: string): string;  //Function implementation is immediately following the declaration.  eat(food) &#123;    return &quot;吃完了&quot;;  &#125;  constructor() &#123;    this.age = 1;    this.sex = &quot;male&quot;;  &#125;&#125;\n\n数组这里应该叫做可索引类型\ninterface Arr &#123;  [index: number]: string;&#125;let arr: Arr = [&quot;1&quot;, &quot;2&quot;];\n\ntype VS interface\n\n\n\ntype\ninterface\n\n\n\n继承\n&amp;（合并）\nextend\n\n\n声明合并\n无\n有\n\n\n定义类类型\n无\n有\n\n\n继承type:\ntype obj3 = obj1 &amp; obj2;let obj: obj3 = &#123;  a: 1,  b: 2,&#125;;\n\ninterface:\ninterface Obj1 &#123;  name: string;&#125;interface Obj2 &#123;  age: number;&#125;interface Obj3 extends Obj1, Obj2 &#123;  sex: &quot;male&quot; | &quot;female&quot;;&#125;let obj: Obj3 = &#123;  name: &quot;leihy&quot;,  age: 22,  sex: &quot;male&quot;,&#125;;\n\n声明合并type: 不存在\ntype Obj1 = &#123;  name: string;&#125;;// Error: Duplicate identifier &#x27;Obj1&#x27;type Obj1 = &#123;  name: string;&#125;;\n\ninterface: 存在\ninterface obj1 &#123;  name: string;&#125;interface obj1 &#123;  name: string;  // 如果有重复属性，类型必须保持一致  age: number;&#125;let person: obj1 = &#123;  name: &quot;leihy&quot;,  age: 1,&#125;;\n\n泛型\n如果我们编写了一个公用的工具，我们需要接收不同的参数来做不同的处理，怎么处理？\n也就是说我们不明确该工具需要什么类型，这个时候就可以使用泛型\n\n// 模拟find方法function find&lt;T&gt;(arr: T[], target: T): T &#123;  let _result;  arr.forEach((item) =&gt; &#123;    if (item === target) &#123;      _result = item;    &#125;  &#125;);  return _result;&#125;find&lt;number&gt;([1, 2], 2);\n\n多个泛型：// 为了确保类型参数 T 和 U 可以安全地与 &#123;&#125; 兼容，我们可以为它们添加 extends &#123;&#125; 约束function combinObj&lt;T extends &#123;&#125;, U extends &#123;&#125;&gt;(obj1: T, obj2: U): T &amp; U &#123;  return Object.assign(obj1, obj2);&#125;combinObj&lt;&#123; a: number &#125;, &#123; b: number &#125;&gt;(&#123; a: 1 &#125;, &#123; b: 2 &#125;);\n\n接口interface Person&lt;T&gt; &#123;  name: string;  sex: T;&#125;// 接口使用泛型必传类型let Mary: Person&lt;number&gt; = &#123;  name: &quot;Mary&quot;,  sex: 0,&#125;;\n\n类class Animal&lt;T&gt; &#123;  characteristic: T;  constructor(obj: T) &#123;    this.characteristic = obj;  &#125;&#125;new Animal(&#123; eyes: 2, foot: 2 &#125;);\n\n\n泛型约束： 使用extends来规定泛型只能接收哪些类型的传值\nfunction find&lt;T extends number | string&gt;(arr: T[], target: T): T\n\n断言\n我们 JavaScript 是非常灵活的，而 ts 是严格类型的，这导致他们可能会存在冲突。 我们可以用as断言来解决这个冲突\n\ninterface UserInfo &#123;  name: string;  age: number;&#125;let Jack = &#123;&#125;;Jack.age = 2; // Property &#x27;age&#x27; does not exist on type &#x27;&#123;&#125;&#x27;\n\n因为 Jack 默认被推断为&#123;&#125;类型， 所以需要使用断言帮助编辑器确定类型：\nlet Jack = &#123;&#125; as UserInfo;\n\n再来看一个函数的例子：\ninterface fn &#123;  (a: string): string;  b: string; // 代表函数必须有个b属性&#125;let f1: fn = ((a) =&gt; &#123;  return &quot;111&quot;;&#125;) as fn;\n\n\n断言也有一种表示：&lt;&gt;, 一般写在需要被断言的代码前，比如let Jack = &lt;UserInfo&gt;&#123;&#125;; ， 这跟泛型很像，所以日常中为了区分，一般还是使用as\n\n","tags":["TypeScript"]},{"title":"TypeScript的应用及踩坑","url":"/blog/2024/06/17/typescript/typescript%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E8%B8%A9%E5%9D%91/","content":"Vue2使用vue-cli创建一个带有typescipt的项目。\n可以在main.ts中看到：\nimport App from &quot;./App.vue&quot;;\n\n实际上， TS 文件是不认识.vue后缀的\n但当我们应用了声明文件shims-vue.d.ts：\ndeclare module &quot;*.vue&quot; &#123;  import Vue from &quot;vue&quot;;  export default Vue;&#125;\n\n就可以在 TS 文件中引入.vue文件了\nimport App from &quot;./App.vue&quot;;\n\n实践工具比如封装一个对数组的对象中的time属性进行排序：\nexport function sortByTime&lt;T&gt;(arr: T[]): T[] &#123;  // 改变了原数组  return arr.sort((a, b) =&gt; &#123;    return a.time - b.time; // Property &#x27;time&#x27; does not exist on type &#x27;T&#x27;  &#125;);&#125;\n\n只要通过extends 限定泛型的参数：\nexport interface TimeData &#123;  name: string;  time: string;  [propName: string]: string | number;&#125;export function sortByTime&lt;T extends TimeData&gt;(arr: T[]): T[];\n\n但是string类型怎么能够相减呢，我们可以：\n\n转为number\nreturn new Date(a.time).getTime() - new Date(b.time).getTime();\n\n断言为any\ns; // return &amp;lt;any&amp;gt;a.time - &amp;lt;any&amp;gt;b.time  断言的另一种写法return (a.time as any) - (b.time as any);\n\n组件import &#123; TimeData &#125; from &quot;@/utils&quot;;// 限定data函数返回的数据interface Data &#123;  list: TimeData[];&#125;export default &#123;  name: &quot;timeList&quot;,  data(): Data &#123;    return &#123;      list: [],    &#125;;  &#125;,&#125;;\n\n这时候去拿后端数据：\nmounted () &#123;    setTimeout(() =&gt; &#123;      this.list = [        &#123; name: &#x27;demo1&#x27;, time: &#x27;2024-06-01&#x27; &#125;,        &#123; name: &#x27;demo2&#x27;, time: &#x27;2024-06-03&#x27; &#125;,        &#123; name: &#x27;demo3&#x27;, time: &#x27;2024-06-02&#x27; &#125;      ]    &#125;, 1000)  &#125;\n\n坏了，报错：Property &#39;list&#39; does not exist on type &#39;&#123; name: string; data(): Data; mounted(): void; &#125;&#39;\n这是因为 this 这时候指向的整个对象，上面只有name, data等属性，找不到list\n我们有两种方法解决这个问题：\n\n修改tsconfig.json\n&quot;noImplicitThis&quot;: false,  // 不再对this进行严格检查\n\n使用Vue.extend\nimport Vue from &#x27;vue&#x27;export default Vue.extend(&#123;  ...,  mounted () &#123;    setTimeout(() =&gt; &#123;      this.list = [        &#123; name: &#x27;demo1&#x27;, time: &#x27;2024-06-01&#x27; &#125;,\t\t...      ]    &#125;, 1000)  &#125;&#125;)// 原理是就是将传入的对象转为一个类，那么在类中的方法通过this拿到属性就没问题了\n\n其他也都是很常规的 TS 用法了\nVue3\n因为 vue-cli 创建的 v3 项目跟 v2 极其接近，这里主要记录 Vite + v3 的项目\nVite 创建的项目是默认支持 TS 的，并且没有tsconfig.json文件，但这有一些问题，暂且不表。\n\nVue3 新增了一些类型， 比如我们定义一个ref\nlet hi = ref(&quot;hi&quot;);// 这时候实际类型是Ref&lt;string&gt;， 而不是Stringhi = &quot;hello&quot;; // Type &#x27;string&#x27; is not assignable to type &#x27;Ref&lt;string&gt;&#x27;\n\n以及computed也会有 ComputedRef&lt;&gt;类型等\ntsxvue3 中也是能够很好的支持 tsx 文件的：\nexport default function Hello() &#123;  return (    &lt;&gt;      &lt;div&gt;hello&lt;/div&gt;    &lt;/&gt;  );&#125;\n\n我们发现存在报错Cannot find name &#39;React&#39;\n这是因为没有配置tsconfig.json:\n&#123;  &quot;compilerOptions&quot;: &#123;    &quot;jsx&quot;: &quot;preserve&quot;  &#125;&#125;\n\n完美解决。\nReact类组件\nclass Test extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      num: 0,    &#125;;  &#125;  render(): React.ReactNode &#123;    return (      &lt;&gt;        // Property &#x27;num&#x27; does not exist on type &#x27;Readonly&lt;&#123;&#125;&gt;&#x27;        &lt;div&gt; &#123;this.state.num&#125; &lt;/div&gt;        // Property &#x27;num2&#x27; does not exist on type &#x27;Readonly&lt;&#123;&#125;&gt;&#x27;        &lt;div&gt; &#123;this.props.num2&#125; &lt;/div&gt;      &lt;/&gt;    );  &#125;&#125;\n\n因为 Component 接收的state和props类型默认都是&#123;&#125;\n我们需要定义好对应的接口：\ninterface StateType &#123;  num: number;&#125;interface Propstype &#123;  num2: number;&#125;class Test extends React.Component&lt;Propstype, StateType&gt;\n\n函数组件\n积累中….\n\n本文主要讲的都是项目开发中可能遇到的一些坑，持续更新\n\n","tags":["TypeScript"]},{"title":"ref与reactive的区别及原理","url":"/blog/2024/05/10/vue3/ref%E4%B8%8Ereactive%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"基本区别ref 可以接收基本值和引用值； reactive 只能接收引用值。\n那么我们到底该如何选择呢？\n直接赋值：\nlet state = reactive(&#123;&#125;);// 上面的 (&#123;&#125;) 引用将不再被追踪// (响应性连接已丢失！)setTimeout(() =&gt; &#123;  state = &#123; count: 1 &#125;;&#125;, 1000);\n\n我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失\n所以此时使用 ref 是最好的,只需要在访问的时候加上.value\nlet state = ref(&#123;&#125;);setTimeout(() =&gt; &#123;  state.value = &#123; count: 1 &#125;; // 正常响应&#125;, 1000);\n\n修改属性\n如果是修改对象中的某个属性,使用reactive()：\nlet state = reactive(&#123; a: 1 &#125;);setTimeout(() =&gt; &#123;  state.a = 666; // 正常响应&#125;, 1000);\n\n其实用ref()也是可以实现的 ：\nlet state = ref(&#123; a: 1 &#125;);setTimeout(() =&gt; &#123;  state.value.a = 666; // 正常响应&#125;, 1000);\n\n那么我们到底该怎么选呢？\n——官方建议使用 ref() 作为声明响应式状态的主要 API。\n逻辑图解\nref 源码解析\nref 方法定义\nfunction ref(value) &#123;  return createRef(value, false);&#125;\n\n返回实例化 RefImpl 类\n\n\n/* * @param &#123;*&#125; rawValue  传入的值 * @param &#123;*&#125; shallow   是否为shallowRef() */function createRef(rawValue, shallow: boolean) &#123;  if (isRef(rawValue)) &#123;    return rawValue;  &#125;  return new RefImpl(rawValue, shallow);&#125;\n\n\n判断是否为引用类型并赋值\n// 如果是引用对象就通过reactive()包装成Proxy, 否则直接返回const toReactive = (value) =&gt; isObject(value) ? reactive(value) : value;class RefImpl &#123;    constructor(value, __v_isShallow) &#123;      ...      this._rawValue = __v_isShallow ? value : toRaw(value); // 后续用于比较      // 把值作为_value属性      this._value = __v_isShallow ? value : toReactive(value);    &#125;&#125;\n\nget 与 set 赋值 value 属性\n\n\nclass RefImpl &#123;    ...    get value() &#123;      const self = toRaw(this);      ...      trackRefValue(self);      return self._value;  // 所以通过.value能够拿到实际存到_value中的值    &#125;\t// 这里也解释了为什么对.value进行整体赋值是触发ref的set，而不是proxy的set    set value(newVal) &#123;      ...      if (hasChanged(newVal, this._rawValue)) &#123;        this._rawValue = newVal;        // 重新赋值也会判断是否为引用值        this._value = useDirectValue ? newVal : toReactive(newVal);\t\t...      &#125;    &#125;&#125;\n\n总结：\n\nref得到的变量必须使用.value 赋值， 否则会失去响应性，变为普通值\nref的值如果是对象，里面的属性也会是响应式的，因为会包装为 proxy\n如果是浅 ref 则不会被包装成 proxy\n\nRective 源码\n\n定义reactive方法\nfunction reactive(target) &#123;    ...    return createReactiveObject(      target,      false,      mutableHandlers,      mutableCollectionHandlers,      ...    );  &#125;\n\n执行createReactiveObject\nfunction createReactiveObject(target,isReadonly2, baseHandlers, collectionHandlers, ...) &#123;    // 不是引用值直接报错    if (!isObject(target)) &#123;      &#123;        console.warn(`value cannot be made reactive: $&#123;String(target)&#125;`);      &#125;      return target;    &#125;    ...    const targetType = getTargetType(target);    const proxy = new Proxy(      target,      targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers    );    ...    return proxy;  &#125;\n\n相当于\nnew Proxy(target, &#123;    ...    /**   * @param target 初始传入的对象   * @param key 获取的属性名   * @param receiver Proxy对象   */    get(target, key, receiver) &#123;      ...      // 一系列判断      return res;    &#125;,    set(target, key, value, receiver) &#123;     ...      const result = Reflect.set(target, key, value, receiver);  //依赖收集      ...      return result;    &#125;&#125;)\n\n","tags":["vue3"]},{"title":"el-select的改造及万能思路","url":"/blog/2024/05/09/vue3/el-seelct%E7%9A%84%E6%94%B9%E9%80%A0%E5%8F%8A%E4%B8%87%E8%83%BD%E6%80%9D%E8%B7%AF/","content":"\n本文所举例子实际在 element-ui 3.0 中已提供相关 API，但这里仍然使用通用思路以便深入理解组件改造\n\n需求element-ui 2.0 中的el-select组件，在选中多个后超出当前宽度会出现高度变形的情况， 如果加上collapse-tags则在选中超出一个选项后，就开始出现+n的省略项。那么如果我们想选中多个之后再开始省略该如何操作？\n基础代码\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;el-select      v-model=&quot;values&quot;      multiple      placeholder=&quot;请选择&quot;      @change=&quot;handleChange&quot;    &gt;      &lt;el-option        v-for=&quot;item in options&quot;        :key=&quot;item.value&quot;        :label=&quot;item.label&quot;        :value=&quot;item.value&quot;      &gt;      &lt;/el-option&gt;    &lt;/el-select&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;name: &#x27;App&#x27;,...&lt;/script&gt;\n\n改造\ncss 样式控制, 从视觉上只显示两个选中的 tag\n.el-tag.el-tag--info:nth-child(n + 3) &#123;  display: none;&#125;\n\n组件挂载时在标签容器的最后添加子元素\nmounted() &#123;   const spanEle = document.createElement(&quot;span&quot;);   spanEle.setAttribute(&quot;class&quot;, &quot;numCounter&quot;);   document.querySelector(&quot;.el-select__tags&quot;).appendChild(spanEle);&#125;,\n\n设置计数元素的默认样式\n.numCounter &#123;  display: none;  background-color: #f4f4f5;  border-color: #e9e9eb;  color: #909399;  height: 24px;  padding: 0 8px;  line-height: 22px;  border-width: 1px;  border-style: solid;  border-radius: 4px;&#125;\n\n这个时候的基本样式已经有了，现在动态控制数值与显示\n// el-select绑定的change事件handleChange() &#123;   // el-select绑定的选中值   const ele = document.querySelector(&quot;.numCounter&quot;);      if (this.values.length &gt; 2) &#123;         ele.setAttribute(&quot;style&quot;, &quot;display:inline-block&quot;);         ele.innerHTML = &quot;+&quot; + (this.values.length - 2);      &#125; else &#123;         ele.setAttribute(&quot;style&quot;, &quot;display:none&quot;);      &#125;&#125;,\n\n到目前为止，自定义的标签省略数量就已经完成了，通过这种思路，我们还可以实现更多的功能，比如限制每个标签的长度等。\n","tags":["vue3"]},{"title":"改造日历组件——渲染函数","url":"/blog/2024/05/08/vue3/%E6%94%B9%E9%80%A0%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0/","content":"\n这篇文章描述了日历组件的二次改造， 在某个存在事项的日期底部显示圆点以及点击可以弹框显示；\n在使用模板时我们会遇到一些问题，最终应该如何去解决。\n\n模板实现&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;el-calendar&gt;      &lt;template v-slot:date-cell=&quot;&#123; data &#125;&quot;&gt;        &lt;!-- 思考： list数据的显示如何处理 ？ --&gt;        &lt;div :class=&quot;handleItemStatus(data.day)&quot;&gt;          &#123;&#123; data.day.split(&quot;-&quot;)[2] &#125;&#125;          &lt;div class=&quot;toolTip&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;        &lt;/div&gt;      &lt;/template&gt;    &lt;/el-calendar&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const handleItemStatus = () =&gt; &#123;    ...    return classObj // 返回一个动态表示class的对象&#125;&lt;/script&gt;\n\n从上面的代码中我们可以看到 两个问题：\n\n没有事项的日期如何处理 toolTip 的显示，如果用 if 判断会产生大量无用循环\n插槽内也无法直接拿到当日的 list 数据， 再次涉及到大量循环\n\n上述情况如果遇到大量数据会对浏览器的性能造成极大的浪费，那么我们该如何解决这个问题？\n渲染函数\n前置知识： https://cn.vuejs.org/guide/extras/render-function.html#jsx-tsx\n\n新建Calendar.ts\nimport &#123; h &#125; from &quot;vue&quot;;export default &#123;  props: &#123;    dataList: [Array],    day: String,  &#125;,  setup(props: any) &#123;    let classes = &#123;      hasItems: false,      finished: false,      unfinished: false,    &#125;;    let itemsList: any = [];    props.dataList.forEach((item: any) =&gt; &#123;      if (item.day === props.day) &#123;        classes.hasItems = true;        itemsList = item.data;        if (item.status === &quot;finished&quot;) &#123;          classes.finished = true;        &#125; else &#123;          classes.unfinished = true;        &#125;      &#125;    &#125;);    // 如果有事项就返回带有tooltip的子节点    if (itemsList.length &gt; 0) &#123;      return () =&gt;        h(&quot;div&quot;, &#123; class: classes &#125;, [          props.day.split(&quot;-&quot;)[2],          h(            &quot;div&quot;,            &#123; class: &quot;toolTip&quot; &#125;,            itemsList.map((item: any) =&gt; h(&quot;div&quot;, item))          ),        ]);    &#125;    // 返回普通日期    return () =&gt; h(&quot;div&quot;, &#123; class: classes &#125;, props.day.split(&quot;-&quot;)[2]);  &#125;,&#125;;\n\n然后在组件中引入：\n&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;el-calendar&gt;      &lt;template v-slot:date-cell=&quot;&#123; data &#125;&quot;&gt;        &lt;CalendarRender :day=&quot;data.day&quot; :dataList=&quot;dataList&quot;&gt;&lt;/CalendarRender&gt;      &lt;/template&gt;    &lt;/el-calendar&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import CalendarRender from &#x27;./components/CalendarRender&#x27;...&lt;/script&gt;\n\n至此，我们实现日历组件的改造只使用到了一次循环！\ncss 样式\n.container &#123;  width: 300px;&#125;.el-calendar-table .el-calendar-day &#123;  height: 36px;  line-height: 36px;  text-align: center;  padding: 0px;  border-radius: 18px;&#125;.el-calendar-table td &#123;  border: 0px;&#125;.el-calendar-table tr td:first-child &#123;  border: 0px;&#125;.container .el-calendar-table td.is-today &#123;  background-color: #409eff;  color: white;  border-radius: 18px;  width: 28px;  height: 28px;&#125;.el-calendar-table td.is-selected &#123;  background-color: transparent;&#125;.hasItems &#123;  position: relative;&#125;.hasItems::after &#123;  position: absolute;  /* text-align: center; */  /* display: none; */  left: 50%;  margin-left: -3px;  bottom: 3px;  content: &quot;&quot;;  width: 6px;  height: 6px;  border-radius: 3px;  background-color: black;&#125;.finished::after &#123;  background-color: rgb(112, 170, 24);&#125;.unfinished::after &#123;  background-color: rgb(214, 214, 231);&#125;.toolTip &#123;  display: none;  position: absolute;  /* bottom: -80px; */  width: 200px;  background-color: white;  border: 1px solid black;  z-index: 999;&#125;.is-selected .toolTip &#123;  display: block;&#125;\n","tags":["vue3"]},{"title":"前端富文本编辑器指南——tinymce","url":"/blog/2024/05/07/vue3/%E5%89%8D%E7%AB%AF%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E6%8C%87%E5%8D%97/","content":"安装注意事项\n\n有两种方案分别是安装对应的 vue&#x2F;react 组件，然后直接用组件；或者直接使用 tinymce 去按原生操作\nnpm install tinymce @tinymce/tinymce-vue\n\n原生方式会报找不到文件的错误，需要把 tinymce 都复制到 public 里, 项目真正上线也要将文件放入服务器静态资源目录\n\n\ntinymce 常见界面需求隐藏不需要的部分：\n\nMenubar 控制菜单栏，\n\ntoolbar 控制工具栏，\n\nstatusbar 控制状态栏\n\n\n自定义样式：\n\nskin 控制皮肤，\n或者通过 skin_url 导入自定义皮肤。\n可以通过 content_css 定义内容区域部分 样式。\nIcons_url 导入图标\n\n中文化：把文件转为二进制形式获取为 blob 对象\n自定义工具栏内容和排序： 把文件转化为二进制形式获取为 blob 对象\n原生操作隐藏不需要的部分import tinymce from &quot;tinymce&quot;;import &#123; onMounted &#125; from &quot;vue&quot;;onMounted(() =&gt; &#123;  tinymce.init(&#123;    base_url: &quot;/tinymce/&quot;, // 改变静态资源读取路径    selector: &quot;.home&quot;, // 编辑器的所在位置， 同css选择器语法    menubar: false, // Possible values: true, false, or string of menus    toolbar: false, // // Possible values: true, false, or string of tools    statusbar: false, // Possible values: true, false  &#125;);&#125;);\n\n自定义样式...onMounted(() =&gt; &#123;  tinymce.init(&#123;    ...,    skin: &#x27;tinymce-5&#x27;, //Possible values: the name of a skin or false    /**     * If you would like to create your own skin     */     skin_url: &#x27;/skins/ui/mySkin&#x27;, // 读取的文件是content.min.css 与 skin.min.css  &#125;)&#125;)\n\n如果不想进行整体样式的替换，进行局部微调，要分为两部分：\n\n工具栏与菜单栏，可直接操作\n.tox-toolbar__primary,.tox-tbtn &#123;  background-color: red !important;&#125;\n\n内容区域， 在 iframe 中，无法直接操作，可通过content_css 进行修改\n...onMounted(() =&gt; &#123;  tinymce.init(&#123;    ...,\tcontent_css: &#x27;/skins/custom/myContent.css&#x27;, // Type: String, Array  &#125;)&#125;)\n\n/* myContent.css */p &#123;  background-color: red;&#125;\n\n中文化语言包官网： https://www.tiny.cloud/get-tiny/language-packages/\n\n下载语言包Chinese Simplified\n\n将langs文件夹放入对应资源下\n\n设置language属性\n...onMounted(() =&gt; &#123;  tinymce.init(&#123;    ...,\tlanguage: &#x27;zh_CN&#x27;,  &#125;)&#125;)\n\n自定义工具栏内容和排序...onMounted(() =&gt; &#123;  tinymce.init(&#123;    ...,\t toolbar: &#x27;undo redo | styles | bold italic | fontfamily fontsize forecolor&#x27;,  &#125;)&#125;)\n\n更多详细配置查看官网文档 https://www.tiny.cloud/docs/tinymce\n组件方式&lt;template&gt;  &lt;!-- 直接引用 --&gt;  &lt;RichEditor&gt;&lt;/RichEditor&gt;&lt;/template&gt;&lt;script setup&gt;import RichEditor from &quot;@tinymce/tinymce-vue&quot;;&lt;/script&gt;\n\n进阶-交互获取输入内容通过编辑器实例的 getContent 方法获得\nconst htmlInfo = tinymce.activeEditor.getContent()  // html结构const text = tinymce.activeEditor.getContent(&#123; format: &#x27;text&#x27; &#125;） //文本tinymce.selection.getContent(） // Returns the selected contents\n\n设置内容通过 setContent 方法设置内容\ntinymce.activeEditor.setContent(&quot;&lt;strong&gt;Some contents&lt;/strong&gt;&quot;);tinymce.activeEditor.selection.setContent(&quot;&lt;strong&gt;Some contents&lt;/strong&gt;&quot;); // 替换被选中的内容\n\n插件使用onMounted(() =&gt; &#123;  tinymce.init(&#123;    toolbar: &quot;undo redo | styles | bold italic | link image&quot;,  &#125;);&#125;);\n\n我们会发现 link 和 image 按钮没有加载， 需要配合插件进行加载：\ntinymce.init(&#123;  plugins: &quot;link, image&quot;, // 会去加载资源文件夹下plugins对应插件的plugin.js文件&#125;);\n\nsetup可以对编辑器进行更多功能上的开发，比如添加工具， 添加事件等；\ntinymce.init(&#123;  setup: function (Editor) &#123;    //添加工具    editor.ui.registry.addButton(&quot;toRed&quot;, &#123;      onAction: () =&gt; &#123;        const text = editor.selection.getContent();        editor.selection.setContent(`&lt;span style=&quot;color: red&quot;&gt;$&#123;text&#125;&lt;/span&gt;`);      &#125;,      icon: &quot;help&quot;,      tooltip: &quot;变红&quot;,      // 要记得在tooBar中添加对应的按钮名toRed    &#125;);    // 添加事件    Editor.on(&quot;change&quot;, () =&gt; &#123;      console.log(&quot;失焦啦&quot;);    &#125;);  &#125;,&#125;);\n","tags":["vue3"]},{"title":"i18n-国际化","url":"/blog/2024/03/18/vue3/i18n-%E5%9B%BD%E9%99%85%E5%8C%96/","content":"基于 vue-i18n V9 的国际化实现方案分析基础用法vue-i18n 的使用可以分为四个部分：\n\n创建 messages 数据源\n创建 locale 语言变量\n初始化 i18n 实例\n注册 i18n 实例\n\n那么接下来我们就去实现以下：\n\n安装 vue-i18n\nnpm install vue-i18n@9\n\n创建 i18n/index.ts 文件\nimport &#123; createI18n &#125; from &#x27;vue-i18n&#x27;;import En from &#x27;./lang/en&#x27;;import Zh from &#x27;./lang/zh&#x27;;import &#123; useAppStore &#125; from &#x27;@/stores/app&#x27;;const messages = &#123;  en: &#123;    ...En  &#125;,  zh: &#123;    ...Zh  &#125;&#125;;// 2. Create i18n instance with optionsconst i18n = createI18n(&#123;  // 使用 Composition API 模式，则需要将其设置为false  legacy: false,  // 全局注入 $t 函数  globalInjection: true,  locale: ’zh&#x27;,  messages&#125;);// Now the app has started!export default i18n;\n\n在APP.vue获取当前语言并持久化：\nimport &#123; useAppStore &#125; from &quot;./stores/app&quot;;import &#123; useI18n &#125; from &quot;vue-i18n&quot;;// 处理自定义国际化const i18n = useI18n();i18n.locale.value = apptore.language;\n\n在 main.js 中导入， 把 i18n 注册到 vue 实例\n// i18n （PS：导入放到 APP.vue 导入之前，因为后面我们会在 app.vue 中使用国际化内容）import i18n from &#x27;@/i18n&#x27;...app.use(i18n)\n\n使用 i18n\n&lt;h1 class=&quot;logo-title&quot; v-if=&quot;$store.getters.sidebarOpened&quot;&gt;  &#123;&#123; $t(&#x27;msg.test&#x27;) &#125;&#125;&lt;/h1&gt;\n\n项目中完成国际化分成以下几步进行:\n\n封装 langSelect 组件用于修改 locale\n导入 el-locale 语言包\n创建自定义语言包\n\n封装 langSelect 组件\n定义 store/app.ts\nimport &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; LANG &#125; from &quot;@/constant&quot;;import &#123; getItem, setItem &#125; from &quot;@/util/storage&quot;;export const useAppStore = defineStore(&quot;app&quot;, &#123;  state: () =&gt; &#123;    return &#123;      language: getItem(LANG) || &quot;zh&quot;,    &#125;;  &#125;,  actions: &#123;    setLanguage(lang: string) &#123;      setItem(LANG, lang);      this.language = lang;    &#125;,  &#125;,&#125;);\n\n在 constant 中定义常量\n// 国际化export const LANG = &quot;language&quot;;\n\n创建 components/LangSelect/index\n&lt;template&gt;  &lt;el-dropdown trigger=&quot;click&quot; @command=&quot;changeLanguage&quot;&gt;    &lt;!-- 如果没有外层div会报错 ：getBoundingClientRect is not a function--&gt;    &lt;div&gt;      &lt;el-tooltip effect=&quot;dark&quot; content=&quot;国际化&quot; placement=&quot;top&quot;&gt;        &lt;svg-icon name=&quot;language&quot;&gt;&lt;/svg-icon&gt;      &lt;/el-tooltip&gt;    &lt;/div&gt;    &lt;template #dropdown&gt;      &lt;el-dropdown-menu&gt;        &lt;el-dropdown-item :disabled=&quot;language === &#x27;zh&#x27;&quot; command=&quot;zh&quot;&gt;          中文        &lt;/el-dropdown-item&gt;        &lt;el-dropdown-item :disabled=&quot;language === &#x27;en&#x27;&quot; command=&quot;en&quot;&gt;          English        &lt;/el-dropdown-item&gt;      &lt;/el-dropdown-menu&gt;    &lt;/template&gt;  &lt;/el-dropdown&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useI18n &#125; from &quot;vue-i18n&quot;; // 在js中引用i18n的情况import &#123; useAppStore &#125; from &quot;@/stores/app&quot;;import &#123; computed &#125; from &quot;vue&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;const appStore = useAppStore();const language = computed(() =&gt; appStore.language);const i18n = useI18n(); // 获取i18n实例const changeLanguage = (lang: string) =&gt; &#123;  i18n.locale.value = lang; // 切换语言  appStore.setLanguage(lang);  ElMessage.success(i18n.t(&quot;toast.switchLangSuccess&quot;));&#125;;&lt;/script&gt;\n\n在 navbar 中导入 LangSelect\n&lt;template&gt;  &lt;div class=&quot;navbar&quot;&gt;    ...    &lt;div class=&quot;right-menu&quot;&gt;      &lt;lang-select class=&quot;right-menu-item hover-effect&quot; /&gt;      ...    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import LangSelect from &#x27;@/components/LangSelect&#x27;...&lt;/script&gt;\n\nelement-plus 国际化处理截止到目前，我们的国际化内容已经基本功能已经处理完成了。接下来需要处理的就是对应的语言包，有了语言包就可以实现整个项目中的所有国际化处理了。\n那么对于语言包来说，我们整个项目中会分成两部分：\n\nelement-plus 语言包：用来处理 element 组件的国际化功能\n自定义语言包：用来处理 非element 组件的国际化功能\n\n先来看看element-plus 语言包：\n&lt;template&gt;  &lt;el-config-provider :locale=&quot;locale&quot;&gt;    &lt;router-view /&gt;  &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ElConfigProvider &#125; from &#x27;element-plus&#x27;;import &#123; computed &#125; from &#x27;vue&#x27;;import &#123; useAppStore &#125; from &#x27;./stores/app&#x27;;import zhCn from &#x27;element-plus/dist/locale/zh-cn.mjs&#x27;;import en from &#x27;element-plus/dist/locale/en.mjs&#x27;;const apptore = useAppStore();const locale = computed(() =&gt; &#123;  return apptore.language === &#x27;zh&#x27; ? zhCn : en;&#125;);&lt;/script&gt;\n\n参考： https://element-plus.org/zh-CN/guide/i18n.html\n自定义语言包国际化处理处理完 element 的国际化内容之后，接下来我们来处理 自定义语言包。\n自定义语言包我们使用了 commonJS 导出了一个对象，这个对象就是所有的\n\n复制 lang 文件夹到 i18n 中\n\n在 lang/index 中，导入语言包\nimport mZhLocale from &quot;./lang/zh&quot;;import mEnLocale from &quot;./lang/en&quot;;\n\n在 messages 中注册到语言包\nconst messages = &#123;  en: &#123;    msg: &#123;      ...mEnLocale,    &#125;,  &#125;,  zh: &#123;    msg: &#123;      ...mZhLocale,    &#125;,  &#125;,&#125;;\n\n最后使用&#x2F;访问：\n在 template 中： $t()\n\n组件 setup 的顶层中：\n&lt;script setup lang=&quot;ts&quot;&gt;  import &#123;useI18n&#125; from &#x27;vue-i18n&#x27;; const i18n = useI18n(); i18n.t() // 访问  i18n.locale.value = &#x27;en&#x27; // 对locale赋值&lt;/script&gt;\n\n非组件的 js 文件中\n\n\nimport i18n from &#x27;@/i18n/index.ts&#x27;  // 默认导出的实例// 赋值i18n.global.value = &#x27;&#x27;；\n","tags":["vue3"]},{"title":"loader的本质","url":"/blog/2023/06/12/webpack/loader%E7%9A%84%E6%9C%AC%E8%B4%A8/","content":"本质\nLoader 本质是一个方法，该方法接受到要处理的资源的内容，处理完后给出内容，作为打包结果\n\n这里手写一个简易的 css-loader 为例：\n//index.jsmodules.exports = function (content) &#123;  console.log(typeof content); //string  let handledContent = content.replace(&quot;0&quot;, &quot;1&quot;);  return handledContent;&#125;;\n\n将自己写的 loader 添加到 webpack 配置中：\nmodule.exports = &#123;  \t...,    module:&#123;        rules:[           ...,            &#123;                test: /\\.css$/i,                use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;,&quot;./my-loader/index.js],      \t\t&#125;,        ]    &#125;,&#125;\n\n打包前：\nbody &#123;  padding: 0px;&#125;\n\n打包后：\nbody &#123;  padding: 1px;&#125;\n\n对应的类型文件给到对应的 loader，然后通过特定的方法去处理，这就是 loader 编译的本质~\n各种语言处理所以基本上各种语言处理都可以看成： 为该语言编写 loader → 配置该 loader\n这里以 typescript 为例，我们最终的目的是要将 TS 的语法转为 JS。\n1.安装相关的包\nnpm install typescript ts-loader --save-dev\n\n2.配置webpack.config.js\nmodule.exports = &#123;  \t...,    module:&#123;        rules:[           \t&#123;    \t\t\ttest: /\\.tsx?$/i,    \t\t\tuse: &#123;    \t\t\t\tloader:&quot;ts-loader&quot;\t\t\t\t&#125;\t\t\t&#125;        ]    &#125;,&#125;\n\n3.在根目录新建tsconfig.json\n&#123;\t...&#125;\n\n4.新建 ts 文件\n//demo.tslet muName: string = &quot;leihy&quot;;console.log(muName);\n\n在入口文件 app.js 中引入该文件并执行打包：\n//app.f378bundle.jsvar muName = &quot;leihy&quot;;console.log(muName);\n\n可以看到是已经打包成功了，以后咱们无论是使用了什么新语法只需要去了解对应的 loader 用法并配置，问题就迎刃而解了。\n","tags":["webpack"]},{"title":"webpack基础","url":"/blog/2023/06/10/webpack/webpack%E5%9F%BA%E7%A1%80/","content":"初识 webpack\n本质上，webpack 是一个用于现代 JavaScript 应用程序的 _静态模块打包工具_。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 _bundles_，它们均为静态资源，用于展示你的内容\n\n这里需要提到开发环境与生产环境的差异：\n开发：\n\n需要模块化、帮助更好的开发\n会使用一些 ES 新语法和框架特殊写法\n\n生产：\n\n浏览器自身无法解析模块化\n浏览器只认识 html、css、js，甚至有些浏览器不识别新的 js 语法\n\n而 webpack 作为构建工具，核心工作就是为了解决开发环境与生产环境的矛盾\n那么构建工具到底帮我们做了什么？\n\n编译浏览器无法理解的东西 —— ES6、TS、Vue 语法等（配合插件、loader）\n代替一些人工操作—— 文件合并和拆分 、 图片压缩 、资源处理等\n辅助开发 —— 开发模式\n\nwebpack 基础配置entry:必须项，以哪个文件开始\noutput:必须项，最终产出 js 的位置\nmode: webpack4 后必填, 告知 webpack 使用相应模式的内置优化\ndevServer: 开发模式配置\nmodule: loader 编写的地方\nplugins：插件配置\noptimization：优化相关\nresolve: 提供一些简化功能\n1.安装 webpack\nnpm i webpack webpack-cli -g //默认为webpack5\n\n如果是局部安装且在项目中配置：\n//package.json&quot;scripts&quot;:&#123;    &quot;dev&quot;: &quot;webpack&quot;  //这时候就是使用局部安装的webpack&#125;\n\n2.基础打包配置\n项目根目录下新建webpack.config.js并配置：\n//因为webpack是用node编写的，编译文件请使用commonjs规范module.exports = &#123;    mode: &quot;production&quot;, //打包模式 none || development || production    //entry:&quot;./app.js&quot; //单入口    //多入口写法    entry: &#123;    \tapp:&quot;./app.js&quot;,    \t//app2:&quot;./app2.js&quot;,\t&#125;,    output: &#123;        path: __dirname + &quot;/dist&quot;,  // 不能是./dist        filename: &quot;[name].[fullhash:4].bundle.js&quot;    &#125;    optimization: &#123;&#125;,    devServer: &#123;&#125;,    resolve:&#123;&#125;    modules: &#123;    \trules: [    \t\t//每个对象都是一个loader    \t\t&#123;    \t\t\ttest:/\\.js/,    \t\t\tloader:...\t\t\t&#125;    \t]\t&#125;,    plugins: [],&#125;\n\nWebpack 处理 jsE6 转化：babel-loader\n代码规范： eslint\n代码的分割和打包: webpack 自身的核心功能\nbabel-loader 的配置1.安装 babel-loader、@babel&#x2F;core（实际起编译作用）\nnpm install babel-loader @babel/core --save-dev\n\n2.配置webpack.config.js\nmodule.exports = &#123;    ...,    module: &#123;    \trules:[    \t\t&#123;    \t\t\ttest: /\\.js/,    \t\t\t//loader:&quot;babel-loader&quot;, //对指定类型文件的处理方案    \t\t\t//如果需要对loader进行配置，则使用use    \t\t\tuse:&#123;    \t\t\t\tloader: &quot;babel-loader&quot;, //如果loader属性传入数组，则从后往前执行loader    \t\t\t\toptions: &#123;    \t\t\t\t\t//options内部的配置就是各个loader都不同了\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;    \t]\t&#125;,&#125;\n\n重新执行编译，这个时候我们会发现 ES6 的语法并没有编译为 ES5。\n打包前：\nlet num = 1;console.log(num);\n\n打包后：\neval(  &quot;let num = 1;\\r\\nconsole.log(num);\\r\\n\\n\\n//# sourceURL=webpack://pack/./app.js?&quot;);\n\n这个时候我就可以通过安装预设环境@babel/preset-env，然后配置 preset：\n...use:&#123;    loader: &quot;babel-loader&quot;, //如果loader属性传入数组，则从后往前执行loader    options: &#123;    \tpresets:[            [            \t&#x27;@babel/preset-env&#x27;,                &#123;                    targets:&#123;                        browsers:[                            &quot;&gt; 1%&quot;, //市场占有率                            &quot;last 2 versions&quot;, //厂商的最近两个版本                            &quot;not ie&lt;=8&quot;                        ]                    &#125;                &#125;            ]        ]\t&#125;&#125;...\n\n这时候就可以看到打包后的文件为 ES5 的语法了\neval(  &quot;var num = 1;\\nconsole.log(num);\\n\\n//# sourceURL=webpack://pack/./app.js?&quot;);\n\n如果配置太多，可以在根目录新建文件babel.config.js，将 options 中的配置在里面暴露可以实现同样的效果\nmodule.exports = &#123;  presets: [    [      &quot;@babel/preset-env&quot;,      &#123;        targets: &#123;          browsers: [            &quot;&gt; 1%&quot;, //市场占有率            &quot;last 2 versions&quot;, //厂商的最近两个版本            &quot;not ie&lt;=8&quot;,          ],        &#125;,      &#125;,    ],  ],&#125;;\n\neslint 的工作在 webpack5 中，eslint-loader 已停止更新， 我们在这里选择eslint-webpack-plugin插件\n1.安装插件\nnpm install eslint eslint-webpack-plugin --save-dev\n\n2.配置webpack.config.js\nconst EslintPlugin = require(&#x27;eslint-webpack-plugin&#x27;);module.exports = &#123;    ...,    plugins: [    \tnew EslintPlugin();    ]&#125;\n\n这个时候也可以像 loader 一样，将配置写在一个单独的文件eslintrc.js中\nmodule.exports = &#123;  //指定一个配置文件可以被基础配置中的已启用的规则继承(默认开启的基本规则，可在下方rules处覆盖)  extends: [    //继承现成的规范，比如eslint-config-standard、eslint-config-airbnb    &quot;eslint-config-standard&quot;,    &quot;plugin:vue/strongly-recommanded&quot;,  ],  env: &#123;    browser: true, //主要是帮助判断使用到的全局变量是否存在于该环境    es2021: true,  &#125;,  //可以提供一些额外的rules，比如vue  plugins: [    &quot;vue&quot;, //可以省略插件名称中的 eslint-plugin- 前缀  ],  parserOptions: &#123;    ecmaVersion: 2015,    sourceType: &quot;module&quot;, //ES6-module  &#125;,  rules: &#123;    &quot;no-console&quot;: &quot;off&quot;,  &#125;,&#125;;\n\ncss 与资源文件的处理css 的处理webpack 只认 js，所以如果在 js 中引入的 css 是无法打包成功的。\n1.安装插件\nnpm install  css-loader style-loader --save-dev\n\n2.配置webpack.config.js\nmodules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;                test: /\\.css$/i,                use: [&quot;style-loader&quot;, &quot;css-loader&quot;],      \t\t&#125;,    \t]\t&#125;&#125;\n\n这个时候 css 就会写入 js 文件中，并通过 style 标签注入 html 文件\n打包前：\n/*app.css*/body &#123;  padding: 0px;&#125;\n\n打包后：\n//app.6fecbundle.js...[module.id, `body &#123;\\r\\n    padding: 0px;\\r\\n&#125;`, \\&quot;\\&quot;]...\n\n如果我们想将 CSS 提取到单独的文件中，需要安装 mini-css-extract-plugin插件，然后配置：\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);modules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;                test: /\\.css$/i,                use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      \t\t&#125;,    \t]\t&#125;&#125;\n\nsass、less 的处理这里以 sass 为例，安装sass-loader, 加载 Sass&#x2F;SCSS 文件并将他们编译为 CSS\nnpm install sass-loader sass --save-dev\n\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);modules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;                test: /\\.css$/i,                use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;,&quot;sass-loader&quot;],      \t\t&#125;,    \t]\t&#125;&#125;\n\n运行 webpack打包生成：\n/*!*****************************************************************************************************!*\\  !*** css ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./style.scss ***!  \\*****************************************************************************************************/body &#123;  color: red;&#125;\n\n但是这里有个问题，会发现 css 代码没有压缩，就算将webpack.config.js的mode设置为 production,也只是去掉注释…..\ncss 代码的压缩与优化安装 css-minimizer-webpack-plugin，并配置\nnpm install css-minimizer-webpack-plugin --save-dev\n\nconst CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);modules.exports = &#123;    ...,    optimization: &#123;        minimizer: [          new CssMinimizerPlugin(),        ],  \t&#125;,&#125;\n\n可以发现代码已经成功压缩了：\nbody &#123;  color: red;&#125;\n\n资源文件的处理在 webpack 5 之前，通常使用：\n​ row-loader将文件导入为字符串\n​ url-loader将文件作为 data URI 内联到 bundle 中(base64)\n​ file-loader将文件发送到输出目录\n更多细节参考：https://www.webpackjs.com/guides/asset-modules/\n而 webpack5 则自带了对资源文件的支持：\n\nasset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\nasset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\nasset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\nasset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n\nmodules.exports = &#123;    ...,    module: &#123;    \trules: [    \t\t...,    \t\t&#123;        \t\ttest: /\\.(png|svg|jpg|jpeg|gif)$/i,\t\t\t\ttype: &#x27;asset&#x27;,  //默认小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型      \t\t\t//如果想要自定义打包base64的文件大小范围：    \t\t\tparser: &#123;         \t\t\tdataUrlCondition: &#123;           \t\t\t\tmaxSize: 4 * 1024 // 4kb         \t\t\t&#125;       \t\t\t&#125;,                generator: &#123;         \t\t\tfilename: &#x27;[name].[fullhash:4][ext]&#x27;       \t\t\t&#125;\t\t\t&#125;,    \t]\t&#125;&#125;\n\nhtml 的处理html 做什么？\n\n给 webpack 提供一个 html 模板给，复用固定内容\n打包的时候再生成一个 html\n打包出来的 html 自动引入 js\n\n对于 html 的处理使用插件、而不是loader\n\n为什么不用 loader?\n这里需要在加强一下 loader 的概念，当非 js 的代码引入到 js 文件，需要使用 loader 去帮助 webpack 识别， 而 html 文件几乎是不会存在引入 js 的情况。\n\n\n安装插件\n\nnpm i html-webpack-plugin --save-dev\n\n\nwebpack.config.js的基本配置\n\n...,const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    ...,    plugins: [    \tnew HtmlWebpackPlugin(&#123;    \t\t/*基础配置*/    \t\ttemplate: &quot;./index.html&quot;,    \t\tfilename: &#x27;index_bundle.html&#x27;    \t\t/*取消默认压缩，便于开发环境调试*/    \t\tminify: &#123;    \t\t\tcollapeWhitespace: false,    \t\t\tremoveComments: false,    \t\t\tremoveAttributeQuotes: false\t\t\t&#125;,\t\t\t/*指定js文件的引入位置*/\t\t\tinject:true,  //true || &#x27;head&#x27; || &#x27;body&#x27; || false\t\t&#125;),  \t]&#125;\n\n打包后，入口 js 文件就会自动引入 html 文件：\n&lt;!-- index_bundle.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;    &lt;title&gt;webpack&lt;/title&gt;    &lt;script defer=&quot;defer&quot; src=&quot;app.b77abundle.js&quot;&gt;&lt;/script&gt;    &lt;link href=&quot;app.css&quot; rel=&quot;stylesheet&quot; /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n多入口的情况：\n...,const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    entry:&#123;        &quot;app1&quot;: &quot;./index.html&quot;,        &quot;app2&quot;: &quot;./index2.html&quot;,    &#125;    ...,    plugins: [    \tnew HtmlWebpackPlugin(&#123;    \t\ttemplate: &quot;./index.html&quot;,    \t\tfilename: &#x27;index.html&#x27;,    \t\tchunks: [&quot;app&quot;],\t\t&#125;),        new HtmlWebpackPlugin(&#123;    \t\ttemplate: &quot;./index2.html&quot;,    \t\tfilename: &#x27;index2.html&#x27;,    \t\tchunks: [&quot;app2&quot;],\t\t&#125;)  \t]&#125;\n\n编写自己的模板及更多细节参考：https://www.npmjs.com/package/html-webpack-plugin\n开发模式安装插件webpack-dev-server\nnpm install webpack-dev-server --save-dev\n\n常用配置//webpack.config.js...,module.exports = &#123;    devServer: &#123;        port: 3000,    \thot: true,  //热更新        /*由webpack-dev-server 开启的node服务来代替我们发送接口请求，避免跨域*/        proxy: &#123;            &#x27;/api&#x27;: &#123;                /*                \t对 /api/users 的请求会将请求代理到 http://localhost:3000/api/users               \t \t不过在控制台中仍然显示的http://localhost:8000/api/hello                */        \t\ttarget: &#x27;http://localhost:3000&#x27;,        \t\tpathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,      \t\t&#125;,        &#125;,         headers: &#123;            //设置响应头        &#125;    &#125;&#125;\n\nwebpack-dev-server 工作原理核心：express + webpack-dev-middleware\n安装：\nnpm install webpack-dev-middleware --save-devnpm install express\n\n原理模拟：\n//mydev.jsconst express = require(&quot;express&quot;);const webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);const webpack = require(&quot;webpack&quot;);const config = reqire(&quot;./webpack.config.js&quot;);/*将配置文件传入webpack方法*/const dist = webpack(config);/*创建express服务*/const app = express();/*注册中间件*/app.use(webpackDevMiddleware(dist));/*挂载服务*/app.listen(3000);\n\n执行node myDev.js就可以实现打包效果。\n\nsource-map当代码出现错误时，source-map 帮助我们定位到打包前的初始代码位置\n//webpack.config.js...,module.exports = &#123;    /*    \teval-cheap-source-map : 开发环境的最佳选择    \tnone: 生产环境    */\tdevTool:&#x27;eval-cheap-source-map&#x27; //&#125;\n","tags":["webpack"]},{"title":"webpack实战","url":"/blog/2023/06/17/webpack/webpack%E5%AE%9E%E6%88%98/","content":"环境为什么需要区分环境?\n生产模式：\n\n需要：代码压缩、tree-shaking、代码混淆等\n不需要：详细的 source-map、开启开发模式\n\n开发模式则相反。\n区分要点：\n\n根据不同环境进行不同的打包，一般在 process.env 中设置\n有的时候需要在 js 代码中获取环境，可以借助插件完成\n\n实战配置提取\n将生产与开发相同的配置提取出来到build/webpack.base.config.js\nconst EslintPlugin = require(&quot;eslint-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  entry: &#123;    app: &quot;./app.js&quot;,    // app2:&quot;./app2.js&quot;,  &#125;,  output: &#123;    path: __dirname + &quot;/dist&quot;,    filename: &quot;[name].[chunkhash:4].bundle.js&quot;,  &#125;,  resolve: &#123;    alias: &#123;      &quot;@css&quot;: &quot;/css&quot;,    &#125;,    extensions: [&quot;.js&quot;],  &#125;,  module: &#123;    rules: [      &#123;        test: /\\.js/,        use: &#123;          loader: &quot;babel-loader&quot;,          options: &#123;&#125;,        &#125;,      &#125;,      &#123;        test: /\\.tsx?/,        use: &#123;          loader: &quot;ts-loader&quot;,        &#125;,      &#125;,      &#123;        test: /\\.css$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      &#125;,      &#123;        test: /\\.scss$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;],      &#125;,      &#123;        test: /\\.(png|svg|jpg|jpeg|gif)$/i,        type: &quot;asset&quot;,        generator: &#123;          filename: &quot;[name].[chunkhash:4][ext]&quot;,        &#125;,        parser: &#123;          dataUrlCondition: &#123;            maxSize: 2 * 1024, // 4kb          &#125;,        &#125;,      &#125;,    ],  &#125;,  plugins: [    // new EslintPlugin()    new MiniCssExtractPlugin(&#123;      filename: &quot;./css/[name].[chunkhash:4].css&quot;,    &#125;),    new HtmlWebpackPlugin(&#123;      template: &quot;./index.html&quot;,      filename: &quot;index.html&quot;,      minify: &#123;        collapeWhitespace: false,        removeComments: false,        removeAttributeQuotes: false,      &#125;,    &#125;),  ],  optimization: &#123;    minimizer: [new CssMinimizerPlugin()],    splitChunks: &#123;      chunks: &quot;all&quot;, //有效值为 all，async 和 initial      cacheGroups: &#123;        vendor: &#123;          test: /[\\\\/]node_modules[\\\\/]/,          name: &quot;vendor&quot;,          minChunks: 1,          chunks: &quot;all&quot;,        &#125;,        commons: &#123;          name: &quot;commons&quot;,          chunks: &quot;initial&quot;,          minChunks: 2,          minSize: 0,        &#125;,      &#125;,    &#125;,    runtimeChunk: &#123;      name: &quot;runtime&quot;,    &#125;,  &#125;,&#125;;\n\n建立开发配置build/webpack.dev.config.js\nconst base = require(&quot;./webpack.base.config&quot;);/*安装base的文件需要安装webpack-merge*/const &#123; merge &#125; = require(&quot;webpack-merge&quot;);module.exports = merge(base, &#123;  mode: &quot;development&quot;,  devServer: &#123;    port: 8000,    hot: true,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:3000&quot;,        pathRewrite: &#123; &quot;^/api&quot;: &quot;&quot; &#125;,      &#125;,    &#125;,    headers: &#123;      &quot;X-Custom-Foo&quot;: &quot;bar&quot;,    &#125;,  &#125;,  devTool: &quot;eval-cheap-source-map&quot;,&#125;);\n\n建立生产配置build/webpack.prod.config.js\nconst base = require(&quot;./webpack.base.config&quot;);const &#123; merge &#125; = require(&quot;webpack-merge&quot;);module.exports = merge(base, &#123;  mode: &quot;production&quot;,&#125;);\n\n获取环境信息：NODE_ENV//package.json&#123;    &quot;scripts&quot;: &#123;        //传值        &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack --config build/webpack.config.dev.js&quot;,\t\t&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.prod.js&quot;  \t&#125;,&#125;//webpack.config.dev.jsconst env = process.env.NODE_ENV //development//webpack.config.prod.jsconst env = process.env.NODE_ENV //production\n\n–envwebpack 特有的属性，需要配置文件暴露一个函数，作了解\n//package.json&#123;    &quot;scripts&quot;: &#123;        //传值\t\t&quot;build&quot;: &quot;cross-env webpack --config build/webpack.config.prod.js --env production&quot;  \t&#125;,&#125;//webpack.config.build.js//使用函数就可以直接拿到接收module.exports = function(env) &#123;    console.log(env) //&#123;..., production:true &#125;    return  merge(base(env), &#123;  //base也要改造成导出一个函数    \tmode:&#x27;production&#x27;,\t&#125;)&#125;\n\n\n上面的两种方法，也只能在配置文件中拿到环境变量，如果想在业务代码中获取环境变量该如何做？\n\n可以使用 webpack 自带的插件DefinePlugin:\n//对应环境的配置文件，比如webpack.config.prod.js...,plugins: [    new webpack.DefinePlugin(&#123;  \t\tVERSION: JSON.stringify(&#x27;5fa3b9&#x27;)  //这里就可以换从环境变量\t&#125;)]//app.34rf.jsconsole.log(&#x27;5fa3b9&#x27;)  //打包前为console.log(VERSION)\n\n打包结果分析\n官方方案：打包时加上–json，将输出的结果分析 json 放到官方进行分析\nwebpack --config ./webpack.prod.config.js --json&gt;stats.json\n\n分析网站: webpack.github.io&#x2F;analyse&#x2F;\n\nwebpack-bundle-analyzer\n\n\n","tags":["webpack"]},{"title":"webpack的技巧性配置","url":"/blog/2023/06/15/webpack/webpack%E6%8A%80%E5%B7%A7%E6%80%A7%E9%85%8D%E7%BD%AE/","content":"hash 值的意义\n浏览器加载了文件后会缓存资源，每次去加载时如果发现文件名一样就会直接使用缓存资源，这就会导致我们重新打包后的文件如果跟之前同名，就会出现浏览器还是读取的以前缓存的问题。\n\n如果我们每次为生成的文件名中附带当次打包的 hash 值，就不会再出现上述情况。\noutput: &#123;    path:__dirname + &quot;/dist&quot;,    filename: &quot;[name].[fullhash:4].bundle.js&quot;&#125;\n\n但是这样会产生其他问题，比如我们现在有分离出来的 js 文件：\n|-dist  |-app.6554.bundle.js  |-index_bundle.html  |-commons.6554.bundle.js  |-vendor.6554.bundle.js\n\n如果我们修改了其中某一个文件的内容，就会导致所有的文件被重新打包生成，不利于浏览器及 webpack 打包时利用未修改的文件\n缓存。\n这时我们可以配置:\n/*将所有的fullhash改为chunkhash*/output: &#123;    path:__dirname + &quot;/dist&quot;,    filename: &quot;[name].[chunkhash:4].bundle.js&quot;&#125;\n\n这时我们发现每个 js 文件生成的 hash 值都不一样了：\n|-dist  |-app.bffb.bundle  |-index_bundle.html  |-runtime.1c33.bundle  |-vendor.2aec.bundle\n\n并且再修改某个独立 chunk 文件的内容打包后发现不会再对每个文件的 hash 值进行改变了。\nresolve这些选项能设置模块如何被解析\n\nalias-别名， 提供路径的简写\n//webpack.config.jsconst path = require(&quot;path&quot;);module.exports = &#123;  //...  resolve: &#123;    alias: &#123;      &quot;@css&quot;: path.resolve(__dirname, &quot;src/image&quot;), //    &#125;,  &#125;,&#125;;\n\n在项目内就可以使用路径简写：\nimport variable from &quot;@css/style.css&quot;;\n\nextensions - 扩展省略， 定义可省略的扩展名\n\n\nresolve: &#123;    ...,    extensions: [&#x27;.js&#x27;, &#x27;.json&#x27;],&#125;,\n\n​ 在项目内就可以引用文件时就可以省略指定的文件后缀：\nimport a from &quot;./a&quot;; //a.js\n\nrequire.context批量引入指定文件夹下的所有文件\n/* 语法 */require.context(  directory, //目录  false, // true || false 是否引入子文件夹的内容 ， 可选  /.js/, //，匹配规则，可选  sync //可选);\n\n/* 实际应用 */const cache = &#123;&#125;;function importAll(r) &#123;  r.keys().forEach((key) =&gt; (cache[key] = r(key)));&#125;importAll(require.context(&quot;../components/&quot;, true, /\\.js$/));\n\n应用场景？\ndist 文件分层以 css 为例，只需要将单独分离文件的配置处加上&#x2F;css 就可以实现\nnew MiniCssExtractPlugin(&#123;     filename:&#x27;/css/[name].[chunkhash:4].css&#x27;&#125;),\n\n其他同理。\n","tags":["webpack"]},{"title":"webpack的技巧性配置","url":"/blog/2023/06/14/webpack/%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/","content":"单入口文件的处理\n单入口意味着所有代码在一个文件里，这样会导致代码过大，所以我们需要把一些不是马上用到并且体积过大的代码拆分出来，以加快首屏渲染速度\n\n这里以引入loadsh为例子：\nimport _ from &quot;lodash&quot;;const element = document.createElement(&quot;div&quot;);element.innerHTML = _.join([&quot;Hello&quot;, &quot;webpack&quot;], &quot; &quot;);document.body.appendChild(element);const initEle = document.createElement(&quot;div&quot;);initEle.innerHTML = &quot;init&quot;;document.body.appendChild(initEle);\n\n通过 webpack 打包后发现 dist 文件中还是只有一个 js 文件，并且包含了loadsh的海量代码。\n|-dist\t|-app.c9d4bundle.js\t|-index_bundle.html\n\n如果我们在页面上渲染内容，就会等到 lodash 中的所有代码加载完毕才会显示 init 文本。\n现在，我们不再静态导入 lodash，而是通过动态异步导入来分离出一个异步 chunk：\nfunction getComponent() &#123;  // 使用 import 引入lodash，其实是一个promise  return import(&quot;lodash&quot;).then((&#123; default: _ &#125;) =&gt; &#123;    const element = document.createElement(&quot;div&quot;);    element.innerHTML = _.join([&quot;Hello&quot;, &quot;webpack&quot;], &quot; &quot;);    return element;  &#125;);&#125;getComponent().then((component) =&gt; &#123;  document.body.appendChild(component);&#125;);const initEle = document.createElement(&quot;div&quot;);initEle.innerHTML = &quot;init&quot;;document.body.appendChild(initEle);\n\n打包后我们发现 lodash 的代码单独分离出来了一个 js 文件：\n|-dist  |-app.9703bundle  |-index_bundle.html  |-vendors-node_modules_lodash_lodash_js.5e1cbundle.js\n\n经过优化后，‘init’字符串就会被先渲染出来，大大提高了首屏渲染速度。\n多入口文件的处理\n多入口的问题主要是重复加载同一段逻辑代码\n\n如果我们在两个 js 入口文件导入了相同的 js 文件。那么在打包后会发现同样的代码会在两个 js 文件中重复出现。\n如何优化：\n//webpack.config.js...module.exports = &#123;    ...,    optimization:&#123;    \tsplitChunks:&#123;    \t\tchunks:&quot;all&quot;,   //有效值为 all，async 和 initial    \t\tminChunks: 2, //拆分前必须共享模块的最小 chunks 数    \t\tminSize:0,   //生成 chunk 的最小体积（以 bytes 为单位）\t\t&#125;\t&#125;&#125;\n\n在打包后发现共同导入的 js 文件单独生成了一个 chunk：\n|-dist  |-app.6554.bundle.js  |-app2.6554.bundle.js  |-index_bundle.html  |-a_js.6554.bundle.js  //单独生成\n\n并且在入口文件中分别引入该 js 文件从而实现一份代码的复用：\n...webpack_require__(/*! ./a.js */ \\&quot;./a.js\\&quot;)...\n\n分离第三方库与运行代码//webpack.config.js...module.exports = &#123;    ...,    optimization:&#123;    \tsplitChunks:&#123;    \t\tchunks:&quot;all&quot;,  \t\t\tcacheGroups: &#123;    \t\t\t/** 第三方库 **/        \t\tvendor: &#123;                  \ttest: /[\\\\/]node_modules[\\\\/]/,                  \tname: &#x27;vendor&#x27;,    \t\t\t\tminChunks:1,   \t \t\t\t\tchunks:&quot;all&quot;,        \t\t&#125;,    \t\t\t/** 通用业务代码 **/    \t\t\tcommons: &#123;                    name: &#x27;commons&#x27;,                    chunks: &#x27;initial&#x27;,                    minChunks: 2,                    minSize: 20000,      \t\t\t&#125;,\t\t&#125;,        /** webpack运行代码 **/        runtimeChunk: &#123;      \t\tname: &#x27;runtime&#x27;,    \t&#125;,\t&#125;&#125;\n\n打包出来的文件：\n|-dist  |-app.6554.bundle.js  |-index_bundle.html  |-a_js.6554.bundle.js  //单独生成  |-commons.随机四位hash.bundle.js  //新版本的  |-vendor.随机四位hash.bundle.js  //单独生成\n\n我们最终要分出来的文件有：\n\n单入口：runtime + vendor + 核心业务 + 异步模块\n多入口：runtime + vendor + 每个入口的核心业务 + common\n\n","tags":["webpack"]},{"title":"node + koa实现bff中间层","url":"/blog/2024/06/30/node/node%20+%20koa%E5%AE%9E%E7%8E%B0bff%E4%B8%AD%E9%97%B4%E5%B1%82/","content":"什么是 BFF？BFF（Backend for Frontend）的核心思想是为每种客户端体创建一个专门的后端服务，这些服务作为中间层，介于前端应用和核心业务逻辑（或数据源）之间\n在前端开发常表现为通过 node 服务去直接返回已经渲染好数据的 html 模板。\n初体验安装koa,koa-router,ejs,koa-view\n配置好基础服务\nconst Koa = require(&quot;koa&quot;);const app = new Koa();const ejs = require(&quot;ejs&quot;);const fs = require(&quot;fs&quot;);// 书写中间件app.use(async (ctx, body) =&gt; &#123;  let _template = fs.readFileSync(&quot;./test.html&quot;);  const _html = await ejs.render(_template, &#123;    msg: &quot;hello bff&quot;,  &#125;);  ctx.body = _html;&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;启动成功, 端口号为3000&quot;);&#125;);\n\n模板内：\n&lt;!--test.html--&gt;...&lt;body&gt;  &lt;%=msg %&gt;&lt;/body&gt;\n\n也可以使用一种不用提前读取文件的方法：\nejs.renderFile(_template, &#123; msg: &quot;hello bff&quot; &#125;, (err, body) =&gt; &#123;  ctx.body = _html;&#125;);\n\n最后还是一种超简单的方式：\nconst views = require(&quot;koa-views&quot;);app.use(views(&quot;./views&quot;, &#123; extension: &quot;ejs&quot; &#125;)); // 不再需要显式的引入ejsapp.use(async (ctx, body) =&gt; &#123;  // render方法被挂在ctx上， 每次渲染都会去views文件夹下查找对应ejs文件  ctx.render(&quot;index&quot;, &#123;    msg: &#x27;hello bff&#x27;  &#125;);&#125;);\n\n实战需求分析：\n首先需要重新划分文件结构：\n--model\t|-detail.js\t|-index.js\t|-login.js--router\t|-index.js--static--views\t|-detail.ejs\t|-index.ejs\t|-login.ejs--app.js--server.js\n\n先来实现登录功能：\n1.编写模型文件：\n// model/login.jsmodule.exports = async function (ctx, next) &#123;  const _template = await ctx.render(&quot;login&quot;);  return _template;&#125;;\n\n2.编写路由, 引入模型\n// router/index.jsconst Router = require(&quot;koa-router&quot;);const router = new Router();const loginModel = require(&quot;../model/login&quot;);router.get(&quot;/login&quot;, async (ctx, next) =&gt; &#123;  const _html = await loginModel(ctx, next);  ctx.body = _html;&#125;);module.exports = router;\n\n不要忘记在根文件中引入：\n// app.jsconst router = require(&quot;./router&quot;);app.use(router.routes());\n\n3.登录的模板：\n&lt;!-- login.ejs --&gt;&lt;body&gt;     &lt;form id=&quot;loginForm&quot;&gt;      &lt;h2&gt;登录&lt;/h2&gt;      &lt;div&gt;        &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;        &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt;        &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt;      &lt;/div&gt;      &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;\n\n4.登录的 js 交互：\n&lt;script&gt;\tdocument.getElementById(&quot;loginForm&quot;).addEventListener(&quot;submit&quot;, function (event) &#123;\t\tevent.preventDefault(); // 阻止表单默认提交行为\t\t// 获取表单输入值        ...\t\taxios.post(&quot;http://localhost:4000/api/login&quot;, &#123;username,password&#125;)\t\t.then((res) =&gt; &#123;            ...        \tlet date = new Date();        \tdate.setTime(date.getTime() + (4 * 60 * 60 * 1000)) // 4 hours            document.cookie = &#x27;cookie=&#x27; + data.cookie + &quot;;expires=&quot; + date.toUTCString();        \twindow.location = &quot;http://localhost:3000&quot;; // 跳转到主页        &#125;);&#125;);&lt;/script&gt;\n\n\n这里的 Axios 是引入的 static 中的axios.min.js, 但是在 koa 中引入静态资源需要安装koa-static,并注册为中间件\n\n实现主页功能：\n1.编写模型文件\n安装request ， 用于发起请求\n// model/index.jsconst request = require(&quot;request&quot;);module.exports = async function (ctx) &#123;  const list = await new Promise((resolve, reject) =&gt; &#123;    request.get(&quot;http://localhost:4000/api/list&quot;, (err, res, body) =&gt; &#123;      resolve(JSON.parse(body)); // 返回的数据是json,需要解析为对象    &#125;);  &#125;);  const _template = await ctx.render(&quot;index&quot;, &#123;    list: list,  &#125;);  return _template;&#125;;\n\n2.添加路由\n// router/index.jsconst indexModel = require(&quot;../model/index&quot;);router.get(&quot;/&quot;, async (ctx, next) =&gt; &#123;  const _html = await indexModel(ctx);  ctx.body = _html;&#125;);\n\n3.主页模板\n&lt;ul&gt;    &lt;% for(let i = 0; i &lt; list.length; i++) &#123; %&gt;        &lt;a href=&lt;%=&quot;http://localhost:3000/detail/&quot; + list[i].id %&gt;&gt;        \t&lt;li&gt;&lt;%= list[i].name %&gt;&lt;/li&gt;        &lt;/a&gt;    &lt;% &#125; %&gt;&lt;/ul&gt;\n\n最后还有一个详情页面不外乎也是这些语法， 就不作阐述了；\nserver.js也就是模拟的后端服务， 挺简单的，不作阐述；\n扩展： cookie 校验\n一定要写在路由中间件之前，不然无法起效果\n//app.jsconst whiteList = [&quot;/login&quot;];app.use(async (ctx, next) =&gt; &#123;  let to = ctx.url;  let cookie = ctx.cookies.get(&quot;cookie&quot;);  if (!whiteList.includes(to)) &#123;    if (!cookie) &#123;      // window.location = &quot;http://localhost:3000/login&quot;; !错误,node中没有window对象      ctx.redirect(&quot;/login&quot;);    &#125; else &#123;      return next();    &#125;  &#125; else &#123;    return next();  &#125;&#125;);\n","tags":["node"]}]