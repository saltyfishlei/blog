[{"title":"test","url":"/2023/12/30/test/","content":"标题副标题标题3加粗文本\n斜体文本\n\n项目1\n项目2\n子项目\n\n\n\n\n有序列表项1\n有序列表项2\n\n链接文本\n\n\n引用文本\n\n行内代码\n# 代码块def hello_world():    print(&quot;Hello, World!&quot;)\n","tags":["前端性能优化"]},{"title":"ts的意义与麻烦","url":"/2023/12/30/The%20meaning%20and%20trouble%20of%20ts/","content":"意义最大的意义就是避免写错变量名，方法名，屏蔽掉低级错误\n\n编写一些公用方法和全局配置对象，用于提醒使用者传参的key值和value类型等\n//apis/users.tsexport interface ListParamsType &#123;    pageNum: number,    pageSize: 10 | 30 | 50  //字面量&#125;export const getList = (params:ListParamsType)=&gt; &#123;    ...这里请求数据&#125;\n\n\n\n声明组件props\n减少传参错误，以及一些不必要的TS报错\ninterface Props &#123;  item: RouteRecordRaw,  basePath?:string&#125;const props = withDefaults(defineProps&lt;Props&gt;(), &#123;    basePath:&#x27;&#x27;&#125;)\n\n一些使用TS编写的第三方库，在使用的时候可以检查有没有调错方法等\n这里以Vue-Router为例：\n//router/index.tsconst router = createRouter(&#123;    history: createWebHistory(),    routes: [        &#123;             path: &#x27;/login&#x27;,             //如果你没有传必需的component属性则会报错            //Type &#x27;&#123; path: string; &#125;&#x27; is not assignable to type &#x27;RouteRecordRaw&#x27;.        &#125;,    ]&#125;)\n\n如果不知道createRouter要传入什么参数可以通过移入鼠标查看\n\n\n\n麻烦\n阶段类型不匹配\n调用初始化为空对象的但是后来会被赋值的属性：\n//SidebarItem.vue&lt;template&gt;    &lt;div v-if=&quot;!item.hidden&quot;&gt;        &lt;template v-if=&quot;hasOneShowingChild(item.children,item)&quot;&gt;             &lt;!-- Property &#x27;path&#x27; does not exist on type &#x27;&#123;&#125;&#x27; --&gt;            &lt;el-menu-item :index=&quot;onlyChild.path&quot;&gt;                 &lt;!-- Property &#x27;title&#x27; does not exist on type &#x27;&#123;&#125;&#x27; --&gt;                &#123;&#123; onlyChild.meta.title &#125;&#125;             &lt;/el-menu-item&gt;        &lt;/template&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;;let onlyChild = reactive(&#123;&#125;);  //就算在代码执行过程中赋值，但是调用处仍然报错&lt;/script&gt;\n\n我们对页面上会调用的变量进行类型定义并断言\n&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;;interface OnlyChildType &#123;    meta:&#123;        title:string    &#125;,    path:string&#125;let onlyChild = reactive(&#123;&#125; as OnlyChildType);&lt;/script&gt;\n\n这个时候去调用meta, path等属性就不会有错误提示了\n\nTS编写的第三方库时，需要定义某个参数为库的某个类型\n我们定义了一个动态添加路由的方法，会出现如下报错\n//Parameter &#x27;routes&#x27; implicitly has an &#x27;any&#x27; typefunction addRoute(routes) &#123;     routes.forEach(route =&gt; &#123;        router.addRoute(route)    &#125;)&#125;\n\n可是要传入第三方库的参数类型我们该怎么定义？\n一般来说，编写较为规范的库都会直接暴露出对应的TS类型可以让我们直接导入\nimport type &#123; RouteRecordRaw &#125; from &#x27;vue-router&#x27;//这个时候使用引入的类型就非常完美了function addRoute(routes:RouteRecordRaw[]) &#123;     routes.forEach(route =&gt; &#123;        router.addRoute(route)    &#125;)&#125;\n\n但是，如果如果不规范的库无法直接导入怎么办？\n​\ta.这里我们还是以Vue-Router为例，通过node_modules找到对应库根目录的package.json\n​\tb.找到其types属性，该属性指向使用import type  导入类型时所查找的位置\n​\tc.然后找到对应的类型查看其如何定义\n\n一些常见的DOM类型报错\n这里以渲染节点文本的内容为例子\n\n\n&lt;div @click=&quot;(e)=&gt;&#123;        let target = e.target         //Property &#x27;innerText&#x27; does not exist on type &#x27;EventTarget&#x27;        target.getContext(&#x27;2D&#x27;)  //因为dom的类型推论错误    &#125;&quot;&gt;&lt;/div&gt;\n\n​\t这时候加上正确的类型断言：\n&lt;div @click=&quot;(e)=&gt;&#123;    let target = e.target as HTMLElement    target.innerTExt = &#x27;test&#x27;&#125;&quot;&gt;\n\n​\t完美解决~\n","tags":["TypeScript"]},{"title":"前端变量的使用和原理","url":"/2023/12/15/%E6%90%9E%E6%87%82%E5%89%8D%E7%AB%AF%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/","content":"不同的环境使用不同的服务器\n开发环境请求的是公司局域网的服务器\n生产环境请求的是真正的服务器，比如云服务\n使用使用 .env.环境名字 定义，运行命令的时候指定环境\nVite + vue3 项目存值：VITE_变量名 &#x3D; xxx\n//.env VITE_GLOBAL = global  //都可以使用//.env.developmentVITE_BASE_URL = 192   //开发环境//.env.production   VITE_BASE_URL = 112  //生产环境-build后的文件内容\n\n取值：import.meta.env.VITE_变量名\nconsole.log(import.meta.env.VITE_BASE_URL)  //生产为112、开发时为192console.log(import.meta.env.VITE_GLOBAL) //都会存在为global\n\n\n\nvue-cli项目 (Webpack + vue2 )存值：VUE_APP_变量名 &#x3D; xxx\n//.env VUE_APP_GLOBAL = global  //都可以使用//.env.developmentVUE_APP_BASE_URL = 192   //开发环境//.env.production   VUE_APP_BASE_URL = 112  //生产环境-build后的文件内容\n\n取值：process.env.VUE_APP_变量名\nconsole.log(import.meta.env.VITE_BASE_URL)  //生产为112、开发时为192console.log(import.meta.env.VITE_GLOBAL) //都会存在为global\n\n指定环境vite//package.json&#123;    &quot;scripts&quot;:&#123;        &quot;dev&quot;:&quot;vite&quot;,  //读取.env.development        &quot;build&quot;:&quot;vite build&quot;,  //读取.env.production           &quot;test&quot;:&quot;vite --mode=test&quot;   //读取.env.test       &#125;&#125;\n\nwebpack//package.json&#123;    &quot;scripts&quot;:&#123;        &quot;serve&quot;:&quot;vue-cli-service serve&quot;,  //读取.env.development        &quot;build&quot;:&quot;vue-cli-service build&quot;,  //读取.env.production           &quot;test&quot;:&quot;vue-cli-service serve --mode=test&quot;   //读取.env.test       &#125;&#125;\n\n\n\n本质node//package.json&#123;    &quot;scripts&quot;: &#123;    \t&quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,    \t&quot;dev&quot;: &quot;cross-env NODE_ENV=development node test.js&quot; //cross-env解决不同系统的兼容性  \t&#125;,&#125;\n\n新建.env文件\n//.envBASE_URL = 127.0.0.1\n\n//main.jsrequire(&#x27;dotenv&#x27;).config() //dotenv库用于从.env文件中读取配置console.log(process.env.NODE_ENV) //developmentconsole.log(process.env.BASE_URL) //127.0.0.1  \n\n纯粹的webpack打包通过definePlugins定义到全局环境\nproject/|-- dist/|-- node_modules/|-- .env|-- app.js|-- package.json|-- webpack.config.js\n\n//package.json&#123;    ...    &quot;scripts&quot;: &#123;        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;    &#125;&#125;//webpack.config.jsmodule.exports = &#123;    mode: process.env.NODE_ENV, //打包方式，是否压缩文件    entry: &quot;./app.js&quot;,    output: &#123;        filename: &#x27;./bundle.js&#x27;    &#125;&#125;\n\n//app.jsconsole.log(process.env)\n\n在这里直接执行npm run build,编译后的文件为：\n//bundle.jsconsole.log(process.env)  //这个代码拿到浏览器中是无法运行的,因为process是node的全局变量\n\n那么如何让process.env直接编译为变量的呢？\n1.引入definePlugin\n//webpack.configlet webpack = require(&#x27;webpack&#x27;);require(&#x27;dotenv&#x27;).config();let obj = &#123;&#125;;Object.keys(process.env).forEach((key) =&gt;&#123;    if (key.indexOf(&#x27;VUE_APP&#x27;) !== -1) &#123;        const ipReg = /\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;/;  //如果直接传入127.0.0.1格式的文本会报错        if (ipReg.test(process.env[key])) &#123;            process.env[key] = `&quot;$&#123;process.env[key]&#125;&quot;`        &#125;        obj[key] = process.env[key]    &#125;&#125;)module.exports = &#123;    .... ,        plugins: [        new webpack.DefinePlugin(&#123;            &quot;process.env&quot; : obj,        &#125;)    ]&#125;\n\n执行npm run build生成bundle.js文件\n//.envVUE_APP_BASE_URL = &#x27;127.0.0.1&#x27;//dist/bundle.jsconsole.log(&#123;VUE_APP_BASE_URL:&quot;127.0.0.1&quot;&#125;),console.log(1111)\n\n这样，我们就成功将环境变量传入process.env了\n","tags":["前端工程化"]}]